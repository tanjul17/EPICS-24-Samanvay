"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@peculiar";
exports.ids = ["vendor-chunks/@peculiar"];
exports.modules = {

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/convert.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/convert.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnConvert = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/./node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(ssr)/./node_modules/pvtsutils/build/index.js\");\nconst parser_1 = __webpack_require__(/*! ./parser */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/parser.js\");\nconst serializer_1 = __webpack_require__(/*! ./serializer */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\");\nclass AsnConvert {\n    static serialize(obj) {\n        return serializer_1.AsnSerializer.serialize(obj);\n    }\n    static parse(data, target) {\n        return parser_1.AsnParser.parse(data, target);\n    }\n    static toString(data) {\n        const buf = pvtsutils_1.BufferSourceConverter.isBufferSource(data)\n            ? pvtsutils_1.BufferSourceConverter.toArrayBuffer(data)\n            : AsnConvert.serialize(data);\n        const asn = asn1js.fromBER(buf);\n        if (asn.offset === -1) {\n            throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);\n        }\n        return asn.result.toString();\n    }\n}\nexports.AsnConvert = AsnConvert;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9jb252ZXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixlQUFlLG1CQUFPLENBQUMsMERBQVE7QUFDL0Isb0JBQW9CLG1CQUFPLENBQUMsZ0VBQVc7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQVU7QUFDbkMscUJBQXFCLG1CQUFPLENBQUMsd0ZBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhcnR1cC1uZXh0anMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9jb252ZXJ0LmpzP2NhM2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzbkNvbnZlcnQgPSB2b2lkIDA7XG5jb25zdCBhc24xanMgPSByZXF1aXJlKFwiYXNuMWpzXCIpO1xuY29uc3QgcHZ0c3V0aWxzXzEgPSByZXF1aXJlKFwicHZ0c3V0aWxzXCIpO1xuY29uc3QgcGFyc2VyXzEgPSByZXF1aXJlKFwiLi9wYXJzZXJcIik7XG5jb25zdCBzZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVyXCIpO1xuY2xhc3MgQXNuQ29udmVydCB7XG4gICAgc3RhdGljIHNlcmlhbGl6ZShvYmopIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXJfMS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShvYmopO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UoZGF0YSwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBwYXJzZXJfMS5Bc25QYXJzZXIucGFyc2UoZGF0YSwgdGFyZ2V0KTtcbiAgICB9XG4gICAgc3RhdGljIHRvU3RyaW5nKGRhdGEpIHtcbiAgICAgICAgY29uc3QgYnVmID0gcHZ0c3V0aWxzXzEuQnVmZmVyU291cmNlQ29udmVydGVyLmlzQnVmZmVyU291cmNlKGRhdGEpXG4gICAgICAgICAgICA/IHB2dHN1dGlsc18xLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGRhdGEpXG4gICAgICAgICAgICA6IEFzbkNvbnZlcnQuc2VyaWFsaXplKGRhdGEpO1xuICAgICAgICBjb25zdCBhc24gPSBhc24xanMuZnJvbUJFUihidWYpO1xuICAgICAgICBpZiAoYXNuLm9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRlY29kZSBBU04uMSBkYXRhLiAke2Fzbi5yZXN1bHQuZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzbi5yZXN1bHQudG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLkFzbkNvbnZlcnQgPSBBc25Db252ZXJ0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/convert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js":
/*!********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/converters.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultConverter = exports.AsnNullConverter = exports.AsnGeneralizedTimeConverter = exports.AsnUTCTimeConverter = exports.AsnCharacterStringConverter = exports.AsnGeneralStringConverter = exports.AsnVisibleStringConverter = exports.AsnGraphicStringConverter = exports.AsnIA5StringConverter = exports.AsnVideotexStringConverter = exports.AsnTeletexStringConverter = exports.AsnPrintableStringConverter = exports.AsnNumericStringConverter = exports.AsnUniversalStringConverter = exports.AsnBmpStringConverter = exports.AsnUtf8StringConverter = exports.AsnConstructedOctetStringConverter = exports.AsnOctetStringConverter = exports.AsnBooleanConverter = exports.AsnObjectIdentifierConverter = exports.AsnBitStringConverter = exports.AsnIntegerBigIntConverter = exports.AsnIntegerArrayBufferConverter = exports.AsnEnumeratedConverter = exports.AsnIntegerConverter = exports.AsnAnyConverter = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/./node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst index_1 = __webpack_require__(/*! ./types/index */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\");\nexports.AsnAnyConverter = {\n    fromASN: (value) => value instanceof asn1js.Null ? null : value.valueBeforeDecodeView,\n    toASN: (value) => {\n        if (value === null) {\n            return new asn1js.Null();\n        }\n        const schema = asn1js.fromBER(value);\n        if (schema.result.error) {\n            throw new Error(schema.result.error);\n        }\n        return schema.result;\n    },\n};\nexports.AsnIntegerConverter = {\n    fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4\n        ? value.valueBlock.toString()\n        : value.valueBlock.valueDec,\n    toASN: (value) => new asn1js.Integer({ value: +value }),\n};\nexports.AsnEnumeratedConverter = {\n    fromASN: (value) => value.valueBlock.valueDec,\n    toASN: (value) => new asn1js.Enumerated({ value }),\n};\nexports.AsnIntegerArrayBufferConverter = {\n    fromASN: (value) => value.valueBlock.valueHexView,\n    toASN: (value) => new asn1js.Integer({ valueHex: value }),\n};\nexports.AsnIntegerBigIntConverter = {\n    fromASN: (value) => value.toBigInt(),\n    toASN: (value) => asn1js.Integer.fromBigInt(value),\n};\nexports.AsnBitStringConverter = {\n    fromASN: (value) => value.valueBlock.valueHexView,\n    toASN: (value) => new asn1js.BitString({ valueHex: value }),\n};\nexports.AsnObjectIdentifierConverter = {\n    fromASN: (value) => value.valueBlock.toString(),\n    toASN: (value) => new asn1js.ObjectIdentifier({ value }),\n};\nexports.AsnBooleanConverter = {\n    fromASN: (value) => value.valueBlock.value,\n    toASN: (value) => new asn1js.Boolean({ value }),\n};\nexports.AsnOctetStringConverter = {\n    fromASN: (value) => value.valueBlock.valueHexView,\n    toASN: (value) => new asn1js.OctetString({ valueHex: value }),\n};\nexports.AsnConstructedOctetStringConverter = {\n    fromASN: (value) => new index_1.OctetString(value.getValue()),\n    toASN: (value) => value.toASN(),\n};\nfunction createStringConverter(Asn1Type) {\n    return {\n        fromASN: (value) => value.valueBlock.value,\n        toASN: (value) => new Asn1Type({ value }),\n    };\n}\nexports.AsnUtf8StringConverter = createStringConverter(asn1js.Utf8String);\nexports.AsnBmpStringConverter = createStringConverter(asn1js.BmpString);\nexports.AsnUniversalStringConverter = createStringConverter(asn1js.UniversalString);\nexports.AsnNumericStringConverter = createStringConverter(asn1js.NumericString);\nexports.AsnPrintableStringConverter = createStringConverter(asn1js.PrintableString);\nexports.AsnTeletexStringConverter = createStringConverter(asn1js.TeletexString);\nexports.AsnVideotexStringConverter = createStringConverter(asn1js.VideotexString);\nexports.AsnIA5StringConverter = createStringConverter(asn1js.IA5String);\nexports.AsnGraphicStringConverter = createStringConverter(asn1js.GraphicString);\nexports.AsnVisibleStringConverter = createStringConverter(asn1js.VisibleString);\nexports.AsnGeneralStringConverter = createStringConverter(asn1js.GeneralString);\nexports.AsnCharacterStringConverter = createStringConverter(asn1js.CharacterString);\nexports.AsnUTCTimeConverter = {\n    fromASN: (value) => value.toDate(),\n    toASN: (value) => new asn1js.UTCTime({ valueDate: value }),\n};\nexports.AsnGeneralizedTimeConverter = {\n    fromASN: (value) => value.toDate(),\n    toASN: (value) => new asn1js.GeneralizedTime({ valueDate: value }),\n};\nexports.AsnNullConverter = {\n    fromASN: () => null,\n    toASN: () => {\n        return new asn1js.Null();\n    },\n};\nfunction defaultConverter(type) {\n    switch (type) {\n        case enums_1.AsnPropTypes.Any:\n            return exports.AsnAnyConverter;\n        case enums_1.AsnPropTypes.BitString:\n            return exports.AsnBitStringConverter;\n        case enums_1.AsnPropTypes.BmpString:\n            return exports.AsnBmpStringConverter;\n        case enums_1.AsnPropTypes.Boolean:\n            return exports.AsnBooleanConverter;\n        case enums_1.AsnPropTypes.CharacterString:\n            return exports.AsnCharacterStringConverter;\n        case enums_1.AsnPropTypes.Enumerated:\n            return exports.AsnEnumeratedConverter;\n        case enums_1.AsnPropTypes.GeneralString:\n            return exports.AsnGeneralStringConverter;\n        case enums_1.AsnPropTypes.GeneralizedTime:\n            return exports.AsnGeneralizedTimeConverter;\n        case enums_1.AsnPropTypes.GraphicString:\n            return exports.AsnGraphicStringConverter;\n        case enums_1.AsnPropTypes.IA5String:\n            return exports.AsnIA5StringConverter;\n        case enums_1.AsnPropTypes.Integer:\n            return exports.AsnIntegerConverter;\n        case enums_1.AsnPropTypes.Null:\n            return exports.AsnNullConverter;\n        case enums_1.AsnPropTypes.NumericString:\n            return exports.AsnNumericStringConverter;\n        case enums_1.AsnPropTypes.ObjectIdentifier:\n            return exports.AsnObjectIdentifierConverter;\n        case enums_1.AsnPropTypes.OctetString:\n            return exports.AsnOctetStringConverter;\n        case enums_1.AsnPropTypes.PrintableString:\n            return exports.AsnPrintableStringConverter;\n        case enums_1.AsnPropTypes.TeletexString:\n            return exports.AsnTeletexStringConverter;\n        case enums_1.AsnPropTypes.UTCTime:\n            return exports.AsnUTCTimeConverter;\n        case enums_1.AsnPropTypes.UniversalString:\n            return exports.AsnUniversalStringConverter;\n        case enums_1.AsnPropTypes.Utf8String:\n            return exports.AsnUtf8StringConverter;\n        case enums_1.AsnPropTypes.VideotexString:\n            return exports.AsnVideotexStringConverter;\n        case enums_1.AsnPropTypes.VisibleString:\n            return exports.AsnVisibleStringConverter;\n        default:\n            return null;\n    }\n}\nexports.defaultConverter = defaultConverter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9jb252ZXJ0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLHdCQUF3QixHQUFHLG1DQUFtQyxHQUFHLDJCQUEyQixHQUFHLG1DQUFtQyxHQUFHLGlDQUFpQyxHQUFHLGlDQUFpQyxHQUFHLGlDQUFpQyxHQUFHLDZCQUE2QixHQUFHLGtDQUFrQyxHQUFHLGlDQUFpQyxHQUFHLG1DQUFtQyxHQUFHLGlDQUFpQyxHQUFHLG1DQUFtQyxHQUFHLDZCQUE2QixHQUFHLDhCQUE4QixHQUFHLDBDQUEwQyxHQUFHLCtCQUErQixHQUFHLDJCQUEyQixHQUFHLG9DQUFvQyxHQUFHLDZCQUE2QixHQUFHLGlDQUFpQyxHQUFHLHNDQUFzQyxHQUFHLDhCQUE4QixHQUFHLDJCQUEyQixHQUFHLHVCQUF1QjtBQUM3M0IsZUFBZSxtQkFBTyxDQUFDLDBEQUFRO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLDBGQUFlO0FBQ3ZDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZUFBZTtBQUMxRDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsMkNBQTJDLGlCQUFpQjtBQUM1RDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsbUNBQW1DO0FBQ25DLGlDQUFpQztBQUNqQyxtQ0FBbUM7QUFDbkMsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQyw2QkFBNkI7QUFDN0IsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsbUNBQW1DO0FBQ25DLDJCQUEyQjtBQUMzQjtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFydHVwLW5leHRqcy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2NvbnZlcnRlcnMuanM/ODkyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdENvbnZlcnRlciA9IGV4cG9ydHMuQXNuTnVsbENvbnZlcnRlciA9IGV4cG9ydHMuQXNuR2VuZXJhbGl6ZWRUaW1lQ29udmVydGVyID0gZXhwb3J0cy5Bc25VVENUaW1lQ29udmVydGVyID0gZXhwb3J0cy5Bc25DaGFyYWN0ZXJTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkdlbmVyYWxTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblZpc2libGVTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkdyYXBoaWNTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbklBNVN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuVmlkZW90ZXhTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblRlbGV0ZXhTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblByaW50YWJsZVN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuTnVtZXJpY1N0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuVW5pdmVyc2FsU3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25CbXBTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblV0ZjhTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkNvbnN0cnVjdGVkT2N0ZXRTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbk9jdGV0U3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25Cb29sZWFuQ29udmVydGVyID0gZXhwb3J0cy5Bc25PYmplY3RJZGVudGlmaWVyQ29udmVydGVyID0gZXhwb3J0cy5Bc25CaXRTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkludGVnZXJCaWdJbnRDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciA9IGV4cG9ydHMuQXNuRW51bWVyYXRlZENvbnZlcnRlciA9IGV4cG9ydHMuQXNuSW50ZWdlckNvbnZlcnRlciA9IGV4cG9ydHMuQXNuQW55Q29udmVydGVyID0gdm9pZCAwO1xuY29uc3QgYXNuMWpzID0gcmVxdWlyZShcImFzbjFqc1wiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi90eXBlcy9pbmRleFwiKTtcbmV4cG9ydHMuQXNuQW55Q29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBhc24xanMuTnVsbCA/IG51bGwgOiB2YWx1ZS52YWx1ZUJlZm9yZURlY29kZVZpZXcsXG4gICAgdG9BU046ICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXNuMWpzLk51bGwoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY2hlbWEgPSBhc24xanMuZnJvbUJFUih2YWx1ZSk7XG4gICAgICAgIGlmIChzY2hlbWEucmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc2NoZW1hLnJlc3VsdC5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYS5yZXN1bHQ7XG4gICAgfSxcbn07XG5leHBvcnRzLkFzbkludGVnZXJDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlSGV4Vmlldy5ieXRlTGVuZ3RoID49IDRcbiAgICAgICAgPyB2YWx1ZS52YWx1ZUJsb2NrLnRvU3RyaW5nKClcbiAgICAgICAgOiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlRGVjLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuSW50ZWdlcih7IHZhbHVlOiArdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25FbnVtZXJhdGVkQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudmFsdWVCbG9jay52YWx1ZURlYyxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgYXNuMWpzLkVudW1lcmF0ZWQoeyB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3LFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuSW50ZWdlcih7IHZhbHVlSGV4OiB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbkludGVnZXJCaWdJbnRDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS50b0JpZ0ludCgpLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IGFzbjFqcy5JbnRlZ2VyLmZyb21CaWdJbnQodmFsdWUpLFxufTtcbmV4cG9ydHMuQXNuQml0U3RyaW5nQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudmFsdWVCbG9jay52YWx1ZUhleFZpZXcsXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IGFzbjFqcy5CaXRTdHJpbmcoeyB2YWx1ZUhleDogdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25PYmplY3RJZGVudGlmaWVyQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudmFsdWVCbG9jay50b1N0cmluZygpLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuT2JqZWN0SWRlbnRpZmllcih7IHZhbHVlIH0pLFxufTtcbmV4cG9ydHMuQXNuQm9vbGVhbkNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWUsXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IGFzbjFqcy5Cb29sZWFuKHsgdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25PY3RldFN0cmluZ0NvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3LFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuT2N0ZXRTdHJpbmcoeyB2YWx1ZUhleDogdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25Db25zdHJ1Y3RlZE9jdGV0U3RyaW5nQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gbmV3IGluZGV4XzEuT2N0ZXRTdHJpbmcodmFsdWUuZ2V0VmFsdWUoKSksXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gdmFsdWUudG9BU04oKSxcbn07XG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoQXNuMVR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWUsXG4gICAgICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBBc24xVHlwZSh7IHZhbHVlIH0pLFxuICAgIH07XG59XG5leHBvcnRzLkFzblV0ZjhTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLlV0ZjhTdHJpbmcpO1xuZXhwb3J0cy5Bc25CbXBTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLkJtcFN0cmluZyk7XG5leHBvcnRzLkFzblVuaXZlcnNhbFN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuVW5pdmVyc2FsU3RyaW5nKTtcbmV4cG9ydHMuQXNuTnVtZXJpY1N0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuTnVtZXJpY1N0cmluZyk7XG5leHBvcnRzLkFzblByaW50YWJsZVN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuUHJpbnRhYmxlU3RyaW5nKTtcbmV4cG9ydHMuQXNuVGVsZXRleFN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuVGVsZXRleFN0cmluZyk7XG5leHBvcnRzLkFzblZpZGVvdGV4U3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5WaWRlb3RleFN0cmluZyk7XG5leHBvcnRzLkFzbklBNVN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuSUE1U3RyaW5nKTtcbmV4cG9ydHMuQXNuR3JhcGhpY1N0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuR3JhcGhpY1N0cmluZyk7XG5leHBvcnRzLkFzblZpc2libGVTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLlZpc2libGVTdHJpbmcpO1xuZXhwb3J0cy5Bc25HZW5lcmFsU3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5HZW5lcmFsU3RyaW5nKTtcbmV4cG9ydHMuQXNuQ2hhcmFjdGVyU3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5DaGFyYWN0ZXJTdHJpbmcpO1xuZXhwb3J0cy5Bc25VVENUaW1lQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudG9EYXRlKCksXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IGFzbjFqcy5VVENUaW1lKHsgdmFsdWVEYXRlOiB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbkdlbmVyYWxpemVkVGltZUNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnRvRGF0ZSgpLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuR2VuZXJhbGl6ZWRUaW1lKHsgdmFsdWVEYXRlOiB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbk51bGxDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKCkgPT4gbnVsbCxcbiAgICB0b0FTTjogKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5OdWxsKCk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBkZWZhdWx0Q29udmVydGVyKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5Bbnk6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25BbnlDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuQml0U3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuQml0U3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkJtcFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkJtcFN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5Cb29sZWFuOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuQm9vbGVhbkNvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5DaGFyYWN0ZXJTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25DaGFyYWN0ZXJTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuRW51bWVyYXRlZDpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkVudW1lcmF0ZWRDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuR2VuZXJhbFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkdlbmVyYWxTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuR2VuZXJhbGl6ZWRUaW1lOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuR2VuZXJhbGl6ZWRUaW1lQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkdyYXBoaWNTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25HcmFwaGljU3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLklBNVN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbklBNVN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5JbnRlZ2VyOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuSW50ZWdlckNvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5OdWxsOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuTnVsbENvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5OdW1lcmljU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuTnVtZXJpY1N0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5PYmplY3RJZGVudGlmaWVyOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuT2JqZWN0SWRlbnRpZmllckNvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5PY3RldFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbk9jdGV0U3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLlByaW50YWJsZVN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzblByaW50YWJsZVN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5UZWxldGV4U3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuVGVsZXRleFN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5VVENUaW1lOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuVVRDVGltZUNvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5Vbml2ZXJzYWxTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25Vbml2ZXJzYWxTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuVXRmOFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzblV0ZjhTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuVmlkZW90ZXhTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25WaWRlb3RleFN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5WaXNpYmxlU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuVmlzaWJsZVN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdENvbnZlcnRlciA9IGRlZmF1bHRDb252ZXJ0ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/decorators.js":
/*!********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/decorators.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnProp = exports.AsnSequenceType = exports.AsnSetType = exports.AsnChoiceType = exports.AsnType = void 0;\nconst converters = __webpack_require__(/*! ./converters */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nconst AsnType = (options) => (target) => {\n    let schema;\n    if (!storage_1.schemaStorage.has(target)) {\n        schema = storage_1.schemaStorage.createDefault(target);\n        storage_1.schemaStorage.set(target, schema);\n    }\n    else {\n        schema = storage_1.schemaStorage.get(target);\n    }\n    Object.assign(schema, options);\n};\nexports.AsnType = AsnType;\nconst AsnChoiceType = () => (0, exports.AsnType)({ type: enums_1.AsnTypeTypes.Choice });\nexports.AsnChoiceType = AsnChoiceType;\nconst AsnSetType = (options) => (0, exports.AsnType)({ type: enums_1.AsnTypeTypes.Set, ...options });\nexports.AsnSetType = AsnSetType;\nconst AsnSequenceType = (options) => (0, exports.AsnType)({ type: enums_1.AsnTypeTypes.Sequence, ...options });\nexports.AsnSequenceType = AsnSequenceType;\nconst AsnProp = (options) => (target, propertyKey) => {\n    let schema;\n    if (!storage_1.schemaStorage.has(target.constructor)) {\n        schema = storage_1.schemaStorage.createDefault(target.constructor);\n        storage_1.schemaStorage.set(target.constructor, schema);\n    }\n    else {\n        schema = storage_1.schemaStorage.get(target.constructor);\n    }\n    const copyOptions = Object.assign({}, options);\n    if (typeof copyOptions.type === \"number\" && !copyOptions.converter) {\n        const defaultConverter = converters.defaultConverter(options.type);\n        if (!defaultConverter) {\n            throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);\n        }\n        copyOptions.converter = defaultConverter;\n    }\n    schema.items[propertyKey] = copyOptions;\n};\nexports.AsnProp = AsnProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9kZWNvcmF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyx1QkFBdUIsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRyxlQUFlO0FBQ3hHLG1CQUFtQixtQkFBTyxDQUFDLHdGQUFjO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFTO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLGtGQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsbURBQW1ELG1DQUFtQztBQUN0RixxQkFBcUI7QUFDckIsdURBQXVELDRDQUE0QztBQUNuRyxrQkFBa0I7QUFDbEIsNERBQTRELGlEQUFpRDtBQUM3Ryx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxZQUFZLE9BQU8sd0JBQXdCO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhcnR1cC1uZXh0anMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9kZWNvcmF0b3JzLmpzP2M5NzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzblByb3AgPSBleHBvcnRzLkFzblNlcXVlbmNlVHlwZSA9IGV4cG9ydHMuQXNuU2V0VHlwZSA9IGV4cG9ydHMuQXNuQ2hvaWNlVHlwZSA9IGV4cG9ydHMuQXNuVHlwZSA9IHZvaWQgMDtcbmNvbnN0IGNvbnZlcnRlcnMgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzXCIpO1xuY29uc3QgZW51bXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zXCIpO1xuY29uc3Qgc3RvcmFnZV8xID0gcmVxdWlyZShcIi4vc3RvcmFnZVwiKTtcbmNvbnN0IEFzblR5cGUgPSAob3B0aW9ucykgPT4gKHRhcmdldCkgPT4ge1xuICAgIGxldCBzY2hlbWE7XG4gICAgaWYgKCFzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5oYXModGFyZ2V0KSkge1xuICAgICAgICBzY2hlbWEgPSBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5jcmVhdGVEZWZhdWx0KHRhcmdldCk7XG4gICAgICAgIHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLnNldCh0YXJnZXQsIHNjaGVtYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzY2hlbWEgPSBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0KTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihzY2hlbWEsIG9wdGlvbnMpO1xufTtcbmV4cG9ydHMuQXNuVHlwZSA9IEFzblR5cGU7XG5jb25zdCBBc25DaG9pY2VUeXBlID0gKCkgPT4gKDAsIGV4cG9ydHMuQXNuVHlwZSkoeyB0eXBlOiBlbnVtc18xLkFzblR5cGVUeXBlcy5DaG9pY2UgfSk7XG5leHBvcnRzLkFzbkNob2ljZVR5cGUgPSBBc25DaG9pY2VUeXBlO1xuY29uc3QgQXNuU2V0VHlwZSA9IChvcHRpb25zKSA9PiAoMCwgZXhwb3J0cy5Bc25UeXBlKSh7IHR5cGU6IGVudW1zXzEuQXNuVHlwZVR5cGVzLlNldCwgLi4ub3B0aW9ucyB9KTtcbmV4cG9ydHMuQXNuU2V0VHlwZSA9IEFzblNldFR5cGU7XG5jb25zdCBBc25TZXF1ZW5jZVR5cGUgPSAob3B0aW9ucykgPT4gKDAsIGV4cG9ydHMuQXNuVHlwZSkoeyB0eXBlOiBlbnVtc18xLkFzblR5cGVUeXBlcy5TZXF1ZW5jZSwgLi4ub3B0aW9ucyB9KTtcbmV4cG9ydHMuQXNuU2VxdWVuY2VUeXBlID0gQXNuU2VxdWVuY2VUeXBlO1xuY29uc3QgQXNuUHJvcCA9IChvcHRpb25zKSA9PiAodGFyZ2V0LCBwcm9wZXJ0eUtleSkgPT4ge1xuICAgIGxldCBzY2hlbWE7XG4gICAgaWYgKCFzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5oYXModGFyZ2V0LmNvbnN0cnVjdG9yKSkge1xuICAgICAgICBzY2hlbWEgPSBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5jcmVhdGVEZWZhdWx0KHRhcmdldC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLnNldCh0YXJnZXQuY29uc3RydWN0b3IsIHNjaGVtYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzY2hlbWEgPSBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0LmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgY29uc3QgY29weU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBpZiAodHlwZW9mIGNvcHlPcHRpb25zLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWNvcHlPcHRpb25zLmNvbnZlcnRlcikge1xuICAgICAgICBjb25zdCBkZWZhdWx0Q29udmVydGVyID0gY29udmVydGVycy5kZWZhdWx0Q29udmVydGVyKG9wdGlvbnMudHlwZSk7XG4gICAgICAgIGlmICghZGVmYXVsdENvbnZlcnRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2V0IGRlZmF1bHQgY29udmVydGVyIGZvciBwcm9wZXJ0eSAnJHtwcm9wZXJ0eUtleX0nIG9mICR7dGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29weU9wdGlvbnMuY29udmVydGVyID0gZGVmYXVsdENvbnZlcnRlcjtcbiAgICB9XG4gICAgc2NoZW1hLml0ZW1zW3Byb3BlcnR5S2V5XSA9IGNvcHlPcHRpb25zO1xufTtcbmV4cG9ydHMuQXNuUHJvcCA9IEFzblByb3A7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/decorators.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js":
/*!***************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/enums.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnPropTypes = exports.AsnTypeTypes = void 0;\nvar AsnTypeTypes;\n(function (AsnTypeTypes) {\n    AsnTypeTypes[AsnTypeTypes[\"Sequence\"] = 0] = \"Sequence\";\n    AsnTypeTypes[AsnTypeTypes[\"Set\"] = 1] = \"Set\";\n    AsnTypeTypes[AsnTypeTypes[\"Choice\"] = 2] = \"Choice\";\n})(AsnTypeTypes || (exports.AsnTypeTypes = AsnTypeTypes = {}));\nvar AsnPropTypes;\n(function (AsnPropTypes) {\n    AsnPropTypes[AsnPropTypes[\"Any\"] = 1] = \"Any\";\n    AsnPropTypes[AsnPropTypes[\"Boolean\"] = 2] = \"Boolean\";\n    AsnPropTypes[AsnPropTypes[\"OctetString\"] = 3] = \"OctetString\";\n    AsnPropTypes[AsnPropTypes[\"BitString\"] = 4] = \"BitString\";\n    AsnPropTypes[AsnPropTypes[\"Integer\"] = 5] = \"Integer\";\n    AsnPropTypes[AsnPropTypes[\"Enumerated\"] = 6] = \"Enumerated\";\n    AsnPropTypes[AsnPropTypes[\"ObjectIdentifier\"] = 7] = \"ObjectIdentifier\";\n    AsnPropTypes[AsnPropTypes[\"Utf8String\"] = 8] = \"Utf8String\";\n    AsnPropTypes[AsnPropTypes[\"BmpString\"] = 9] = \"BmpString\";\n    AsnPropTypes[AsnPropTypes[\"UniversalString\"] = 10] = \"UniversalString\";\n    AsnPropTypes[AsnPropTypes[\"NumericString\"] = 11] = \"NumericString\";\n    AsnPropTypes[AsnPropTypes[\"PrintableString\"] = 12] = \"PrintableString\";\n    AsnPropTypes[AsnPropTypes[\"TeletexString\"] = 13] = \"TeletexString\";\n    AsnPropTypes[AsnPropTypes[\"VideotexString\"] = 14] = \"VideotexString\";\n    AsnPropTypes[AsnPropTypes[\"IA5String\"] = 15] = \"IA5String\";\n    AsnPropTypes[AsnPropTypes[\"GraphicString\"] = 16] = \"GraphicString\";\n    AsnPropTypes[AsnPropTypes[\"VisibleString\"] = 17] = \"VisibleString\";\n    AsnPropTypes[AsnPropTypes[\"GeneralString\"] = 18] = \"GeneralString\";\n    AsnPropTypes[AsnPropTypes[\"CharacterString\"] = 19] = \"CharacterString\";\n    AsnPropTypes[AsnPropTypes[\"UTCTime\"] = 20] = \"UTCTime\";\n    AsnPropTypes[AsnPropTypes[\"GeneralizedTime\"] = 21] = \"GeneralizedTime\";\n    AsnPropTypes[AsnPropTypes[\"DATE\"] = 22] = \"DATE\";\n    AsnPropTypes[AsnPropTypes[\"TimeOfDay\"] = 23] = \"TimeOfDay\";\n    AsnPropTypes[AsnPropTypes[\"DateTime\"] = 24] = \"DateTime\";\n    AsnPropTypes[AsnPropTypes[\"Duration\"] = 25] = \"Duration\";\n    AsnPropTypes[AsnPropTypes[\"TIME\"] = 26] = \"TIME\";\n    AsnPropTypes[AsnPropTypes[\"Null\"] = 27] = \"Null\";\n})(AsnPropTypes || (exports.AsnPropTypes = AsnPropTypes = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9lbnVtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CLG9CQUFvQixvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CLG9CQUFvQixvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFydHVwLW5leHRqcy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2VudW1zLmpzPzUxODEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzblByb3BUeXBlcyA9IGV4cG9ydHMuQXNuVHlwZVR5cGVzID0gdm9pZCAwO1xudmFyIEFzblR5cGVUeXBlcztcbihmdW5jdGlvbiAoQXNuVHlwZVR5cGVzKSB7XG4gICAgQXNuVHlwZVR5cGVzW0FzblR5cGVUeXBlc1tcIlNlcXVlbmNlXCJdID0gMF0gPSBcIlNlcXVlbmNlXCI7XG4gICAgQXNuVHlwZVR5cGVzW0FzblR5cGVUeXBlc1tcIlNldFwiXSA9IDFdID0gXCJTZXRcIjtcbiAgICBBc25UeXBlVHlwZXNbQXNuVHlwZVR5cGVzW1wiQ2hvaWNlXCJdID0gMl0gPSBcIkNob2ljZVwiO1xufSkoQXNuVHlwZVR5cGVzIHx8IChleHBvcnRzLkFzblR5cGVUeXBlcyA9IEFzblR5cGVUeXBlcyA9IHt9KSk7XG52YXIgQXNuUHJvcFR5cGVzO1xuKGZ1bmN0aW9uIChBc25Qcm9wVHlwZXMpIHtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiQW55XCJdID0gMV0gPSBcIkFueVwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJCb29sZWFuXCJdID0gMl0gPSBcIkJvb2xlYW5cIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiT2N0ZXRTdHJpbmdcIl0gPSAzXSA9IFwiT2N0ZXRTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiQml0U3RyaW5nXCJdID0gNF0gPSBcIkJpdFN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJJbnRlZ2VyXCJdID0gNV0gPSBcIkludGVnZXJcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiRW51bWVyYXRlZFwiXSA9IDZdID0gXCJFbnVtZXJhdGVkXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIk9iamVjdElkZW50aWZpZXJcIl0gPSA3XSA9IFwiT2JqZWN0SWRlbnRpZmllclwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJVdGY4U3RyaW5nXCJdID0gOF0gPSBcIlV0ZjhTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiQm1wU3RyaW5nXCJdID0gOV0gPSBcIkJtcFN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJVbml2ZXJzYWxTdHJpbmdcIl0gPSAxMF0gPSBcIlVuaXZlcnNhbFN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJOdW1lcmljU3RyaW5nXCJdID0gMTFdID0gXCJOdW1lcmljU3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlByaW50YWJsZVN0cmluZ1wiXSA9IDEyXSA9IFwiUHJpbnRhYmxlU3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlRlbGV0ZXhTdHJpbmdcIl0gPSAxM10gPSBcIlRlbGV0ZXhTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiVmlkZW90ZXhTdHJpbmdcIl0gPSAxNF0gPSBcIlZpZGVvdGV4U3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIklBNVN0cmluZ1wiXSA9IDE1XSA9IFwiSUE1U3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkdyYXBoaWNTdHJpbmdcIl0gPSAxNl0gPSBcIkdyYXBoaWNTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiVmlzaWJsZVN0cmluZ1wiXSA9IDE3XSA9IFwiVmlzaWJsZVN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJHZW5lcmFsU3RyaW5nXCJdID0gMThdID0gXCJHZW5lcmFsU3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkNoYXJhY3RlclN0cmluZ1wiXSA9IDE5XSA9IFwiQ2hhcmFjdGVyU3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlVUQ1RpbWVcIl0gPSAyMF0gPSBcIlVUQ1RpbWVcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiR2VuZXJhbGl6ZWRUaW1lXCJdID0gMjFdID0gXCJHZW5lcmFsaXplZFRpbWVcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiREFURVwiXSA9IDIyXSA9IFwiREFURVwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJUaW1lT2ZEYXlcIl0gPSAyM10gPSBcIlRpbWVPZkRheVwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJEYXRlVGltZVwiXSA9IDI0XSA9IFwiRGF0ZVRpbWVcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiRHVyYXRpb25cIl0gPSAyNV0gPSBcIkR1cmF0aW9uXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlRJTUVcIl0gPSAyNl0gPSBcIlRJTUVcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiTnVsbFwiXSA9IDI3XSA9IFwiTnVsbFwiO1xufSkoQXNuUHJvcFR5cGVzIHx8IChleHBvcnRzLkFzblByb3BUeXBlcyA9IEFzblByb3BUeXBlcyA9IHt9KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\ntslib_1.__exportStar(__webpack_require__(/*! ./schema_validation */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9lcnJvcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsdURBQU87QUFDL0IscUJBQXFCLG1CQUFPLENBQUMsNkdBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhcnR1cC1uZXh0anMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9lcnJvcnMvaW5kZXguanM/ZDcyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zY2hlbWFfdmFsaWRhdGlvblwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnSchemaValidationError = void 0;\nclass AsnSchemaValidationError extends Error {\n    constructor() {\n        super(...arguments);\n        this.schemas = [];\n    }\n}\nexports.AsnSchemaValidationError = AsnSchemaValidationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9lcnJvcnMvc2NoZW1hX3ZhbGlkYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YXJ0dXAtbmV4dGpzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZXJyb3JzL3NjaGVtYV92YWxpZGF0aW9uLmpzP2NjY2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzblNjaGVtYVZhbGlkYXRpb25FcnJvciA9IHZvaWQgMDtcbmNsYXNzIEFzblNjaGVtYVZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0gW107XG4gICAgfVxufVxuZXhwb3J0cy5Bc25TY2hlbWFWYWxpZGF0aW9uRXJyb3IgPSBBc25TY2hlbWFWYWxpZGF0aW9uRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js":
/*!****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/helper.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isArrayEqual = exports.isTypeOfArray = exports.isConvertible = void 0;\nfunction isConvertible(target) {\n    if (typeof target === \"function\" && target.prototype) {\n        if (target.prototype.toASN && target.prototype.fromASN) {\n            return true;\n        }\n        else {\n            return isConvertible(target.prototype);\n        }\n    }\n    else {\n        return !!(target && typeof target === \"object\" && \"toASN\" in target && \"fromASN\" in target);\n    }\n}\nexports.isConvertible = isConvertible;\nfunction isTypeOfArray(target) {\n    var _a;\n    if (target) {\n        const proto = Object.getPrototypeOf(target);\n        if (((_a = proto === null || proto === void 0 ? void 0 : proto.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === Array) {\n            return true;\n        }\n        return isTypeOfArray(proto);\n    }\n    return false;\n}\nexports.isTypeOfArray = isTypeOfArray;\nfunction isArrayEqual(bytes1, bytes2) {\n    if (!(bytes1 && bytes2)) {\n        return false;\n    }\n    if (bytes1.byteLength !== bytes2.byteLength) {\n        return false;\n    }\n    const b1 = new Uint8Array(bytes1);\n    const b2 = new Uint8Array(bytes2);\n    for (let i = 0; i < bytes1.byteLength; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isArrayEqual = isArrayEqual;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9oZWxwZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFydHVwLW5leHRqcy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2hlbHBlci5qcz84NTdkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0FycmF5RXF1YWwgPSBleHBvcnRzLmlzVHlwZU9mQXJyYXkgPSBleHBvcnRzLmlzQ29udmVydGlibGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBpc0NvbnZlcnRpYmxlKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIgJiYgdGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZS50b0FTTiAmJiB0YXJnZXQucHJvdG90eXBlLmZyb21BU04pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzQ29udmVydGlibGUodGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAhISh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gXCJvYmplY3RcIiAmJiBcInRvQVNOXCIgaW4gdGFyZ2V0ICYmIFwiZnJvbUFTTlwiIGluIHRhcmdldCk7XG4gICAgfVxufVxuZXhwb3J0cy5pc0NvbnZlcnRpYmxlID0gaXNDb252ZXJ0aWJsZTtcbmZ1bmN0aW9uIGlzVHlwZU9mQXJyYXkodGFyZ2V0KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgICAgICAgaWYgKCgoX2EgPSBwcm90byA9PT0gbnVsbCB8fCBwcm90byA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvdG8ucHJvdG90eXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uc3RydWN0b3IpID09PSBBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVHlwZU9mQXJyYXkocHJvdG8pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzVHlwZU9mQXJyYXkgPSBpc1R5cGVPZkFycmF5O1xuZnVuY3Rpb24gaXNBcnJheUVxdWFsKGJ5dGVzMSwgYnl0ZXMyKSB7XG4gICAgaWYgKCEoYnl0ZXMxICYmIGJ5dGVzMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYnl0ZXMxLmJ5dGVMZW5ndGggIT09IGJ5dGVzMi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYjEgPSBuZXcgVWludDhBcnJheShieXRlczEpO1xuICAgIGNvbnN0IGIyID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzMS5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGIxW2ldICE9PSBiMltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc0FycmF5RXF1YWwgPSBpc0FycmF5RXF1YWw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnSerializer = exports.AsnParser = exports.AsnPropTypes = exports.AsnTypeTypes = exports.AsnSetType = exports.AsnSequenceType = exports.AsnChoiceType = exports.AsnType = exports.AsnProp = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\ntslib_1.__exportStar(__webpack_require__(/*! ./converters */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./types/index */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\"), exports);\nvar decorators_1 = __webpack_require__(/*! ./decorators */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/decorators.js\");\nObject.defineProperty(exports, \"AsnProp\", ({ enumerable: true, get: function () { return decorators_1.AsnProp; } }));\nObject.defineProperty(exports, \"AsnType\", ({ enumerable: true, get: function () { return decorators_1.AsnType; } }));\nObject.defineProperty(exports, \"AsnChoiceType\", ({ enumerable: true, get: function () { return decorators_1.AsnChoiceType; } }));\nObject.defineProperty(exports, \"AsnSequenceType\", ({ enumerable: true, get: function () { return decorators_1.AsnSequenceType; } }));\nObject.defineProperty(exports, \"AsnSetType\", ({ enumerable: true, get: function () { return decorators_1.AsnSetType; } }));\nvar enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nObject.defineProperty(exports, \"AsnTypeTypes\", ({ enumerable: true, get: function () { return enums_1.AsnTypeTypes; } }));\nObject.defineProperty(exports, \"AsnPropTypes\", ({ enumerable: true, get: function () { return enums_1.AsnPropTypes; } }));\nvar parser_1 = __webpack_require__(/*! ./parser */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/parser.js\");\nObject.defineProperty(exports, \"AsnParser\", ({ enumerable: true, get: function () { return parser_1.AsnParser; } }));\nvar serializer_1 = __webpack_require__(/*! ./serializer */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\");\nObject.defineProperty(exports, \"AsnSerializer\", ({ enumerable: true, get: function () { return serializer_1.AsnSerializer; } }));\ntslib_1.__exportStar(__webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./objects */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/objects.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./convert */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/convert.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxrQkFBa0IsR0FBRyx1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRyxlQUFlLEdBQUcsZUFBZTtBQUNsTSxnQkFBZ0IsbUJBQU8sQ0FBQyx1REFBTztBQUMvQixxQkFBcUIsbUJBQU8sQ0FBQyx3RkFBYztBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQywwRkFBZTtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQyx3RkFBYztBQUN6QywyQ0FBMEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDbEgsMkNBQTBDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ2xILGlEQUFnRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUM5SCxtREFBa0QsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDbEksOENBQTZDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3hILGNBQWMsbUJBQU8sQ0FBQyw4RUFBUztBQUMvQixnREFBK0MsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDdkgsZ0RBQStDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3ZILGVBQWUsbUJBQU8sQ0FBQyxnRkFBVTtBQUNqQyw2Q0FBNEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDbEgsbUJBQW1CLG1CQUFPLENBQUMsd0ZBQWM7QUFDekMsaURBQWdELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQzlILHFCQUFxQixtQkFBTyxDQUFDLHNGQUFVO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLGtGQUFXO0FBQ3hDLHFCQUFxQixtQkFBTyxDQUFDLGtGQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhcnR1cC1uZXh0anMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9pbmRleC5qcz85Y2M2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25TZXJpYWxpemVyID0gZXhwb3J0cy5Bc25QYXJzZXIgPSBleHBvcnRzLkFzblByb3BUeXBlcyA9IGV4cG9ydHMuQXNuVHlwZVR5cGVzID0gZXhwb3J0cy5Bc25TZXRUeXBlID0gZXhwb3J0cy5Bc25TZXF1ZW5jZVR5cGUgPSBleHBvcnRzLkFzbkNob2ljZVR5cGUgPSBleHBvcnRzLkFzblR5cGUgPSBleHBvcnRzLkFzblByb3AgPSB2b2lkIDA7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29udmVydGVyc1wiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy9pbmRleFwiKSwgZXhwb3J0cyk7XG52YXIgZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIi4vZGVjb3JhdG9yc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblByb3BcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29yYXRvcnNfMS5Bc25Qcm9wOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNuVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb3JhdG9yc18xLkFzblR5cGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25DaG9pY2VUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvcmF0b3JzXzEuQXNuQ2hvaWNlVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblNlcXVlbmNlVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb3JhdG9yc18xLkFzblNlcXVlbmNlVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblNldFR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29yYXRvcnNfMS5Bc25TZXRUeXBlOyB9IH0pO1xudmFyIGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblR5cGVUeXBlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW51bXNfMS5Bc25UeXBlVHlwZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25Qcm9wVHlwZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudW1zXzEuQXNuUHJvcFR5cGVzOyB9IH0pO1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4vcGFyc2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNuUGFyc2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZXJfMS5Bc25QYXJzZXI7IH0gfSk7XG52YXIgc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXplclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblNlcmlhbGl6ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcmlhbGl6ZXJfMS5Bc25TZXJpYWxpemVyOyB9IH0pO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJyb3JzXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29iamVjdHNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29udmVydFwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/objects.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/objects.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnArray = void 0;\nclass AsnArray extends Array {\n    constructor(items = []) {\n        if (typeof items === \"number\") {\n            super(items);\n        }\n        else {\n            super();\n            for (const item of items) {\n                this.push(item);\n            }\n        }\n    }\n}\nexports.AsnArray = AsnArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9vYmplY3RzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YXJ0dXAtbmV4dGpzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvb2JqZWN0cy5qcz8xMzY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25BcnJheSA9IHZvaWQgMDtcbmNsYXNzIEFzbkFycmF5IGV4dGVuZHMgQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yKGl0ZW1zID0gW10pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgc3VwZXIoaXRlbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQXNuQXJyYXkgPSBBc25BcnJheTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/objects.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/parser.js":
/*!****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/parser.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnParser = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/./node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst converters = __webpack_require__(/*! ./converters */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nclass AsnParser {\n    static parse(data, target) {\n        const asn1Parsed = asn1js.fromBER(data);\n        if (asn1Parsed.result.error) {\n            throw new Error(asn1Parsed.result.error);\n        }\n        const res = this.fromASN(asn1Parsed.result, target);\n        return res;\n    }\n    static fromASN(asn1Schema, target) {\n        var _a;\n        try {\n            if ((0, helper_1.isConvertible)(target)) {\n                const value = new target();\n                return value.fromASN(asn1Schema);\n            }\n            const schema = storage_1.schemaStorage.get(target);\n            storage_1.schemaStorage.cache(target);\n            let targetSchema = schema.schema;\n            if (asn1Schema.constructor === asn1js.Constructed && schema.type !== enums_1.AsnTypeTypes.Choice) {\n                targetSchema = new asn1js.Constructed({\n                    idBlock: {\n                        tagClass: 3,\n                        tagNumber: asn1Schema.idBlock.tagNumber,\n                    },\n                    value: schema.schema.valueBlock.value,\n                });\n                for (const key in schema.items) {\n                    delete asn1Schema[key];\n                }\n            }\n            const asn1ComparedSchema = asn1js.compareSchema({}, asn1Schema, targetSchema);\n            if (!asn1ComparedSchema.verified) {\n                throw new errors_1.AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);\n            }\n            const res = new target();\n            if ((0, helper_1.isTypeOfArray)(target)) {\n                if (!(\"value\" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {\n                    throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);\n                }\n                const itemType = schema.itemType;\n                if (typeof itemType === \"number\") {\n                    const converter = converters.defaultConverter(itemType);\n                    if (!converter) {\n                        throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n                    }\n                    return target.from(asn1Schema.valueBlock.value, (element) => converter.fromASN(element));\n                }\n                else {\n                    return target.from(asn1Schema.valueBlock.value, (element) => this.fromASN(element, itemType));\n                }\n            }\n            for (const key in schema.items) {\n                const asn1SchemaValue = asn1ComparedSchema.result[key];\n                if (!asn1SchemaValue) {\n                    continue;\n                }\n                const schemaItem = schema.items[key];\n                const schemaItemType = schemaItem.type;\n                if (typeof schemaItemType === \"number\" || (0, helper_1.isConvertible)(schemaItemType)) {\n                    const converter = (_a = schemaItem.converter) !== null && _a !== void 0 ? _a : ((0, helper_1.isConvertible)(schemaItemType)\n                        ? new schemaItemType()\n                        : null);\n                    if (!converter) {\n                        throw new Error(\"Converter is empty\");\n                    }\n                    if (schemaItem.repeated) {\n                        if (schemaItem.implicit) {\n                            const Container = schemaItem.repeated === \"sequence\"\n                                ? asn1js.Sequence\n                                : asn1js.Set;\n                            const newItem = new Container();\n                            newItem.valueBlock = asn1SchemaValue.valueBlock;\n                            const newItemAsn = asn1js.fromBER(newItem.toBER(false));\n                            if (newItemAsn.offset === -1) {\n                                throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);\n                            }\n                            if (!(\"value\" in newItemAsn.result.valueBlock && Array.isArray(newItemAsn.result.valueBlock.value))) {\n                                throw new Error(\"Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.\");\n                            }\n                            const value = newItemAsn.result.valueBlock.value;\n                            res[key] = Array.from(value, (element) => converter.fromASN(element));\n                        }\n                        else {\n                            res[key] = Array.from(asn1SchemaValue, (element) => converter.fromASN(element));\n                        }\n                    }\n                    else {\n                        let value = asn1SchemaValue;\n                        if (schemaItem.implicit) {\n                            let newItem;\n                            if ((0, helper_1.isConvertible)(schemaItemType)) {\n                                newItem = new schemaItemType().toSchema(\"\");\n                            }\n                            else {\n                                const Asn1TypeName = enums_1.AsnPropTypes[schemaItemType];\n                                const Asn1Type = asn1js[Asn1TypeName];\n                                if (!Asn1Type) {\n                                    throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);\n                                }\n                                newItem = new Asn1Type();\n                            }\n                            newItem.valueBlock = value.valueBlock;\n                            value = asn1js.fromBER(newItem.toBER(false)).result;\n                        }\n                        res[key] = converter.fromASN(value);\n                    }\n                }\n                else {\n                    if (schemaItem.repeated) {\n                        if (!Array.isArray(asn1SchemaValue)) {\n                            throw new Error(\"Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.\");\n                        }\n                        res[key] = Array.from(asn1SchemaValue, (element) => this.fromASN(element, schemaItemType));\n                    }\n                    else {\n                        res[key] = this.fromASN(asn1SchemaValue, schemaItemType);\n                    }\n                }\n            }\n            return res;\n        }\n        catch (error) {\n            if (error instanceof errors_1.AsnSchemaValidationError) {\n                error.schemas.push(target.name);\n            }\n            throw error;\n        }\n    }\n}\nexports.AsnParser = AsnParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGVBQWUsbUJBQU8sQ0FBQywwREFBUTtBQUMvQixnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBUztBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyx3RkFBYztBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQyxzRkFBVTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBVTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxrRkFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSxzRkFBc0YsYUFBYSxlQUFlLGdDQUFnQztBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixhQUFhO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRix3QkFBd0I7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YXJ0dXAtbmV4dGpzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvcGFyc2VyLmpzP2FiMzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzblBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IGFzbjFqcyA9IHJlcXVpcmUoXCJhc24xanNcIik7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG5jb25zdCBjb252ZXJ0ZXJzID0gcmVxdWlyZShcIi4vY29udmVydGVyc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgaGVscGVyXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG5jb25zdCBzdG9yYWdlXzEgPSByZXF1aXJlKFwiLi9zdG9yYWdlXCIpO1xuY2xhc3MgQXNuUGFyc2VyIHtcbiAgICBzdGF0aWMgcGFyc2UoZGF0YSwgdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IGFzbjFQYXJzZWQgPSBhc24xanMuZnJvbUJFUihkYXRhKTtcbiAgICAgICAgaWYgKGFzbjFQYXJzZWQucmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXNuMVBhcnNlZC5yZXN1bHQuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuZnJvbUFTTihhc24xUGFyc2VkLnJlc3VsdCwgdGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc3RhdGljIGZyb21BU04oYXNuMVNjaGVtYSwgdGFyZ2V0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICgoMCwgaGVscGVyXzEuaXNDb252ZXJ0aWJsZSkodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5mcm9tQVNOKGFzbjFTY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5jYWNoZSh0YXJnZXQpO1xuICAgICAgICAgICAgbGV0IHRhcmdldFNjaGVtYSA9IHNjaGVtYS5zY2hlbWE7XG4gICAgICAgICAgICBpZiAoYXNuMVNjaGVtYS5jb25zdHJ1Y3RvciA9PT0gYXNuMWpzLkNvbnN0cnVjdGVkICYmIHNjaGVtYS50eXBlICE9PSBlbnVtc18xLkFzblR5cGVUeXBlcy5DaG9pY2UpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTY2hlbWEgPSBuZXcgYXNuMWpzLkNvbnN0cnVjdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnQ2xhc3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IGFzbjFTY2hlbWEuaWRCbG9jay50YWdOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzY2hlbWEuc2NoZW1hLnZhbHVlQmxvY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhc24xU2NoZW1hW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXNuMUNvbXBhcmVkU2NoZW1hID0gYXNuMWpzLmNvbXBhcmVTY2hlbWEoe30sIGFzbjFTY2hlbWEsIHRhcmdldFNjaGVtYSk7XG4gICAgICAgICAgICBpZiAoIWFzbjFDb21wYXJlZFNjaGVtYS52ZXJpZmllZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bc25TY2hlbWFWYWxpZGF0aW9uRXJyb3IoYERhdGEgZG9lcyBub3QgbWF0Y2ggdG8gJHt0YXJnZXQubmFtZX0gQVNOMSBzY2hlbWEuICR7YXNuMUNvbXBhcmVkU2NoZW1hLnJlc3VsdC5lcnJvcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyB0YXJnZXQoKTtcbiAgICAgICAgICAgIGlmICgoMCwgaGVscGVyXzEuaXNUeXBlT2ZBcnJheSkodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGlmICghKFwidmFsdWVcIiBpbiBhc24xU2NoZW1hLnZhbHVlQmxvY2sgJiYgQXJyYXkuaXNBcnJheShhc24xU2NoZW1hLnZhbHVlQmxvY2sudmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgaXRlbXMgZnJvbSB0aGUgQVNOLjEgcGFyc2VkIHZhbHVlLiBBU04uMSBvYmplY3QgaXMgbm90IGNvbnN0cnVjdGVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtVHlwZSA9IHNjaGVtYS5pdGVtVHlwZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW1UeXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IGNvbnZlcnRlcnMuZGVmYXVsdENvbnZlcnRlcihpdGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgZGVmYXVsdCBjb252ZXJ0ZXIgZm9yIGFycmF5IGl0ZW0gb2YgJHt0YXJnZXQubmFtZX0gQVNOMSBzY2hlbWFgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmZyb20oYXNuMVNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlLCAoZWxlbWVudCkgPT4gY29udmVydGVyLmZyb21BU04oZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5mcm9tKGFzbjFTY2hlbWEudmFsdWVCbG9jay52YWx1ZSwgKGVsZW1lbnQpID0+IHRoaXMuZnJvbUFTTihlbGVtZW50LCBpdGVtVHlwZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzbjFTY2hlbWFWYWx1ZSA9IGFzbjFDb21wYXJlZFNjaGVtYS5yZXN1bHRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIWFzbjFTY2hlbWFWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hSXRlbSA9IHNjaGVtYS5pdGVtc1trZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYUl0ZW1UeXBlID0gc2NoZW1hSXRlbS50eXBlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hSXRlbVR5cGUgPT09IFwibnVtYmVyXCIgfHwgKDAsIGhlbHBlcl8xLmlzQ29udmVydGlibGUpKHNjaGVtYUl0ZW1UeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSAoX2EgPSBzY2hlbWFJdGVtLmNvbnZlcnRlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKCgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShzY2hlbWFJdGVtVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IHNjaGVtYUl0ZW1UeXBlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb252ZXJ0ZXIgaXMgZW1wdHlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYUl0ZW0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFJdGVtLmltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgQ29udGFpbmVyID0gc2NoZW1hSXRlbS5yZXBlYXRlZCA9PT0gXCJzZXF1ZW5jZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYXNuMWpzLlNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYXNuMWpzLlNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdJdGVtID0gbmV3IENvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0l0ZW0udmFsdWVCbG9jayA9IGFzbjFTY2hlbWFWYWx1ZS52YWx1ZUJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW1Bc24gPSBhc24xanMuZnJvbUJFUihuZXdJdGVtLnRvQkVSKGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0l0ZW1Bc24ub2Zmc2V0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSB0aGUgY2hpbGQgaXRlbS4gJHtuZXdJdGVtQXNuLnJlc3VsdC5lcnJvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoXCJ2YWx1ZVwiIGluIG5ld0l0ZW1Bc24ucmVzdWx0LnZhbHVlQmxvY2sgJiYgQXJyYXkuaXNBcnJheShuZXdJdGVtQXNuLnJlc3VsdC52YWx1ZUJsb2NrLnZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBpdGVtcyBmcm9tIHRoZSBBU04uMSBwYXJzZWQgdmFsdWUuIEFTTi4xIG9iamVjdCBpcyBub3QgY29uc3RydWN0ZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5ld0l0ZW1Bc24ucmVzdWx0LnZhbHVlQmxvY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBBcnJheS5mcm9tKHZhbHVlLCAoZWxlbWVudCkgPT4gY29udmVydGVyLmZyb21BU04oZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBBcnJheS5mcm9tKGFzbjFTY2hlbWFWYWx1ZSwgKGVsZW1lbnQpID0+IGNvbnZlcnRlci5mcm9tQVNOKGVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGFzbjFTY2hlbWFWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFJdGVtLmltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0l0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShzY2hlbWFJdGVtVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SXRlbSA9IG5ldyBzY2hlbWFJdGVtVHlwZSgpLnRvU2NoZW1hKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgQXNuMVR5cGVOYW1lID0gZW51bXNfMS5Bc25Qcm9wVHlwZXNbc2NoZW1hSXRlbVR5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBBc24xVHlwZSA9IGFzbjFqc1tBc24xVHlwZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUFzbjFUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgJyR7QXNuMVR5cGVOYW1lfScgY2xhc3MgZnJvbSBhc24xanMgbW9kdWxlYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SXRlbSA9IG5ldyBBc24xVHlwZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJdGVtLnZhbHVlQmxvY2sgPSB2YWx1ZS52YWx1ZUJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXNuMWpzLmZyb21CRVIobmV3SXRlbS50b0JFUihmYWxzZSkpLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gY29udmVydGVyLmZyb21BU04odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hSXRlbS5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFzbjFTY2hlbWFWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGxpc3Qgb2YgaXRlbXMgZnJvbSB0aGUgQVNOLjEgcGFyc2VkIHZhbHVlLiBBU04uMSB2YWx1ZSBzaG91bGQgYmUgaXRlcmFibGUuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBBcnJheS5mcm9tKGFzbjFTY2hlbWFWYWx1ZSwgKGVsZW1lbnQpID0+IHRoaXMuZnJvbUFTTihlbGVtZW50LCBzY2hlbWFJdGVtVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSB0aGlzLmZyb21BU04oYXNuMVNjaGVtYVZhbHVlLCBzY2hlbWFJdGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZXJyb3JzXzEuQXNuU2NoZW1hVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Iuc2NoZW1hcy5wdXNoKHRhcmdldC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Bc25QYXJzZXIgPSBBc25QYXJzZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/schema.js":
/*!****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/schema.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnSchemaStorage = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/./node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nclass AsnSchemaStorage {\n    constructor() {\n        this.items = new WeakMap();\n    }\n    has(target) {\n        return this.items.has(target);\n    }\n    get(target, checkSchema = false) {\n        const schema = this.items.get(target);\n        if (!schema) {\n            throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);\n        }\n        if (checkSchema && !schema.schema) {\n            throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);\n        }\n        return schema;\n    }\n    cache(target) {\n        const schema = this.get(target);\n        if (!schema.schema) {\n            schema.schema = this.create(target, true);\n        }\n    }\n    createDefault(target) {\n        const schema = {\n            type: enums_1.AsnTypeTypes.Sequence,\n            items: {},\n        };\n        const parentSchema = this.findParentSchema(target);\n        if (parentSchema) {\n            Object.assign(schema, parentSchema);\n            schema.items = Object.assign({}, schema.items, parentSchema.items);\n        }\n        return schema;\n    }\n    create(target, useNames) {\n        const schema = this.items.get(target) || this.createDefault(target);\n        const asn1Value = [];\n        for (const key in schema.items) {\n            const item = schema.items[key];\n            const name = useNames ? key : \"\";\n            let asn1Item;\n            if (typeof (item.type) === \"number\") {\n                const Asn1TypeName = enums_1.AsnPropTypes[item.type];\n                const Asn1Type = asn1js[Asn1TypeName];\n                if (!Asn1Type) {\n                    throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);\n                }\n                asn1Item = new Asn1Type({ name });\n            }\n            else if ((0, helper_1.isConvertible)(item.type)) {\n                const instance = new item.type();\n                asn1Item = instance.toSchema(name);\n            }\n            else if (item.optional) {\n                const itemSchema = this.get(item.type);\n                if (itemSchema.type === enums_1.AsnTypeTypes.Choice) {\n                    asn1Item = new asn1js.Any({ name });\n                }\n                else {\n                    asn1Item = this.create(item.type, false);\n                    asn1Item.name = name;\n                }\n            }\n            else {\n                asn1Item = new asn1js.Any({ name });\n            }\n            const optional = !!item.optional || item.defaultValue !== undefined;\n            if (item.repeated) {\n                asn1Item.name = \"\";\n                const Container = item.repeated === \"set\"\n                    ? asn1js.Set\n                    : asn1js.Sequence;\n                asn1Item = new Container({\n                    name: \"\",\n                    value: [\n                        new asn1js.Repeated({\n                            name,\n                            value: asn1Item,\n                        }),\n                    ],\n                });\n            }\n            if (item.context !== null && item.context !== undefined) {\n                if (item.implicit) {\n                    if (typeof item.type === \"number\" || (0, helper_1.isConvertible)(item.type)) {\n                        const Container = item.repeated\n                            ? asn1js.Constructed\n                            : asn1js.Primitive;\n                        asn1Value.push(new Container({\n                            name,\n                            optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: item.context,\n                            },\n                        }));\n                    }\n                    else {\n                        this.cache(item.type);\n                        const isRepeated = !!item.repeated;\n                        let value = !isRepeated\n                            ? this.get(item.type, true).schema\n                            : asn1Item;\n                        value = \"valueBlock\" in value ? value.valueBlock.value : value.value;\n                        asn1Value.push(new asn1js.Constructed({\n                            name: !isRepeated ? name : \"\",\n                            optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: item.context,\n                            },\n                            value: value,\n                        }));\n                    }\n                }\n                else {\n                    asn1Value.push(new asn1js.Constructed({\n                        optional,\n                        idBlock: {\n                            tagClass: 3,\n                            tagNumber: item.context,\n                        },\n                        value: [asn1Item],\n                    }));\n                }\n            }\n            else {\n                asn1Item.optional = optional;\n                asn1Value.push(asn1Item);\n            }\n        }\n        switch (schema.type) {\n            case enums_1.AsnTypeTypes.Sequence:\n                return new asn1js.Sequence({ value: asn1Value, name: \"\" });\n            case enums_1.AsnTypeTypes.Set:\n                return new asn1js.Set({ value: asn1Value, name: \"\" });\n            case enums_1.AsnTypeTypes.Choice:\n                return new asn1js.Choice({ value: asn1Value, name: \"\" });\n            default:\n                throw new Error(`Unsupported ASN1 type in use`);\n        }\n    }\n    set(target, schema) {\n        this.items.set(target, schema);\n        return this;\n    }\n    findParentSchema(target) {\n        const parent = Object.getPrototypeOf(target);\n        if (parent) {\n            const schema = this.items.get(parent);\n            return schema || this.findParentSchema(parent);\n        }\n        return null;\n    }\n}\nexports.AsnSchemaStorage = AsnSchemaStorage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9zY2hlbWEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCLGVBQWUsbUJBQU8sQ0FBQywwREFBUTtBQUMvQixnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBUztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQ0FBa0M7QUFDeEY7QUFDQTtBQUNBLHVDQUF1QyxrQ0FBa0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsYUFBYTtBQUNuRjtBQUNBLDBDQUEwQyxNQUFNO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxNQUFNO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDRCQUE0QjtBQUN6RTtBQUNBLHdDQUF3Qyw0QkFBNEI7QUFDcEU7QUFDQSwyQ0FBMkMsNEJBQTRCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFydHVwLW5leHRqcy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3NjaGVtYS5qcz8wNTBmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25TY2hlbWFTdG9yYWdlID0gdm9pZCAwO1xuY29uc3QgYXNuMWpzID0gcmVxdWlyZShcImFzbjFqc1wiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbmNvbnN0IGhlbHBlcl8xID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuY2xhc3MgQXNuU2NoZW1hU3RvcmFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICBoYXModGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmhhcyh0YXJnZXQpO1xuICAgIH1cbiAgICBnZXQodGFyZ2V0LCBjaGVja1NjaGVtYSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuaXRlbXMuZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmICghc2NoZW1hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgc2NoZW1hIGZvciAnJHt0YXJnZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWV9JyB0YXJnZXRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tTY2hlbWEgJiYgIXNjaGVtYS5zY2hlbWEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2NoZW1hICcke3RhcmdldC5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZX0nIGRvZXNuJ3QgY29udGFpbiBBU04uMSBzY2hlbWEuIENhbGwgJ0FzblNjaGVtYVN0b3JhZ2UuY2FjaGUnLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIGNhY2hlKHRhcmdldCkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoIXNjaGVtYS5zY2hlbWEpIHtcbiAgICAgICAgICAgIHNjaGVtYS5zY2hlbWEgPSB0aGlzLmNyZWF0ZSh0YXJnZXQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZURlZmF1bHQodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHtcbiAgICAgICAgICAgIHR5cGU6IGVudW1zXzEuQXNuVHlwZVR5cGVzLlNlcXVlbmNlLFxuICAgICAgICAgICAgaXRlbXM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXJlbnRTY2hlbWEgPSB0aGlzLmZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KTtcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzY2hlbWEsIHBhcmVudFNjaGVtYSk7XG4gICAgICAgICAgICBzY2hlbWEuaXRlbXMgPSBPYmplY3QuYXNzaWduKHt9LCBzY2hlbWEuaXRlbXMsIHBhcmVudFNjaGVtYS5pdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgY3JlYXRlKHRhcmdldCwgdXNlTmFtZXMpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5pdGVtcy5nZXQodGFyZ2V0KSB8fCB0aGlzLmNyZWF0ZURlZmF1bHQodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgYXNuMVZhbHVlID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS5pdGVtc1trZXldO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHVzZU5hbWVzID8ga2V5IDogXCJcIjtcbiAgICAgICAgICAgIGxldCBhc24xSXRlbTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGl0ZW0udHlwZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBBc24xVHlwZU5hbWUgPSBlbnVtc18xLkFzblByb3BUeXBlc1tpdGVtLnR5cGVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IEFzbjFUeXBlID0gYXNuMWpzW0FzbjFUeXBlTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKCFBc24xVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgQVNOMSBjbGFzcyBieSBuYW1lICcke0FzbjFUeXBlTmFtZX0nYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gbmV3IEFzbjFUeXBlKHsgbmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgaXRlbS50eXBlKCk7XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSBpbnN0YW5jZS50b1NjaGVtYShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtU2NoZW1hID0gdGhpcy5nZXQoaXRlbS50eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVNjaGVtYS50eXBlID09PSBlbnVtc18xLkFzblR5cGVUeXBlcy5DaG9pY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSBuZXcgYXNuMWpzLkFueSh7IG5hbWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc24xSXRlbSA9IHRoaXMuY3JlYXRlKGl0ZW0udHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhc24xSXRlbS5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IG5ldyBhc24xanMuQW55KHsgbmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbmFsID0gISFpdGVtLm9wdGlvbmFsIHx8IGl0ZW0uZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaXRlbS5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IENvbnRhaW5lciA9IGl0ZW0ucmVwZWF0ZWQgPT09IFwic2V0XCJcbiAgICAgICAgICAgICAgICAgICAgPyBhc24xanMuU2V0XG4gICAgICAgICAgICAgICAgICAgIDogYXNuMWpzLlNlcXVlbmNlO1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gbmV3IENvbnRhaW5lcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgYXNuMWpzLlJlcGVhdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhc24xSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0uY29udGV4dCAhPT0gbnVsbCAmJiBpdGVtLmNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbS50eXBlID09PSBcIm51bWJlclwiIHx8ICgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBDb250YWluZXIgPSBpdGVtLnJlcGVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhc24xanMuQ29uc3RydWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFzbjFqcy5QcmltaXRpdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChuZXcgQ29udGFpbmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkQmxvY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnQ2xhc3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ051bWJlcjogaXRlbS5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlKGl0ZW0udHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1JlcGVhdGVkID0gISFpdGVtLnJlcGVhdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gIWlzUmVwZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZ2V0KGl0ZW0udHlwZSwgdHJ1ZSkuc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhc24xSXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXCJ2YWx1ZUJsb2NrXCIgaW4gdmFsdWUgPyB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlIDogdmFsdWUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChuZXcgYXNuMWpzLkNvbnN0cnVjdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAhaXNSZXBlYXRlZCA/IG5hbWUgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkQmxvY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnQ2xhc3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ051bWJlcjogaXRlbS5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChuZXcgYXNuMWpzLkNvbnN0cnVjdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0NsYXNzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ051bWJlcjogaXRlbS5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbYXNuMUl0ZW1dLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0ub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChhc24xSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzY2hlbWEudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBlbnVtc18xLkFzblR5cGVUeXBlcy5TZXF1ZW5jZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5TZXF1ZW5jZSh7IHZhbHVlOiBhc24xVmFsdWUsIG5hbWU6IFwiXCIgfSk7XG4gICAgICAgICAgICBjYXNlIGVudW1zXzEuQXNuVHlwZVR5cGVzLlNldDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5TZXQoeyB2YWx1ZTogYXNuMVZhbHVlLCBuYW1lOiBcIlwiIH0pO1xuICAgICAgICAgICAgY2FzZSBlbnVtc18xLkFzblR5cGVUeXBlcy5DaG9pY2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc24xanMuQ2hvaWNlKHsgdmFsdWU6IGFzbjFWYWx1ZSwgbmFtZTogXCJcIiB9KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBBU04xIHR5cGUgaW4gdXNlYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KHRhcmdldCwgc2NoZW1hKSB7XG4gICAgICAgIHRoaXMuaXRlbXMuc2V0KHRhcmdldCwgc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLml0ZW1zLmdldChwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYSB8fCB0aGlzLmZpbmRQYXJlbnRTY2hlbWEocGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkFzblNjaGVtYVN0b3JhZ2UgPSBBc25TY2hlbWFTdG9yYWdlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/schema.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js":
/*!********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnSerializer = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/./node_modules/asn1js/build/index.js\");\nconst converters = __webpack_require__(/*! ./converters */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nclass AsnSerializer {\n    static serialize(obj) {\n        if (obj instanceof asn1js.BaseBlock) {\n            return obj.toBER(false);\n        }\n        return this.toASN(obj).toBER(false);\n    }\n    static toASN(obj) {\n        if (obj && typeof obj === \"object\" && (0, helper_1.isConvertible)(obj)) {\n            return obj.toASN();\n        }\n        if (!(obj && typeof obj === \"object\")) {\n            throw new TypeError(\"Parameter 1 should be type of Object.\");\n        }\n        const target = obj.constructor;\n        const schema = storage_1.schemaStorage.get(target);\n        storage_1.schemaStorage.cache(target);\n        let asn1Value = [];\n        if (schema.itemType) {\n            if (!Array.isArray(obj)) {\n                throw new TypeError(\"Parameter 1 should be type of Array.\");\n            }\n            if (typeof schema.itemType === \"number\") {\n                const converter = converters.defaultConverter(schema.itemType);\n                if (!converter) {\n                    throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n                }\n                asn1Value = obj.map((o) => converter.toASN(o));\n            }\n            else {\n                asn1Value = obj.map((o) => this.toAsnItem({ type: schema.itemType }, \"[]\", target, o));\n            }\n        }\n        else {\n            for (const key in schema.items) {\n                const schemaItem = schema.items[key];\n                const objProp = obj[key];\n                if (objProp === undefined\n                    || schemaItem.defaultValue === objProp\n                    || (typeof schemaItem.defaultValue === \"object\" && typeof objProp === \"object\"\n                        && (0, helper_1.isArrayEqual)(this.serialize(schemaItem.defaultValue), this.serialize(objProp)))) {\n                    continue;\n                }\n                const asn1Item = AsnSerializer.toAsnItem(schemaItem, key, target, objProp);\n                if (typeof schemaItem.context === \"number\") {\n                    if (schemaItem.implicit) {\n                        if (!schemaItem.repeated\n                            && (typeof schemaItem.type === \"number\" || (0, helper_1.isConvertible)(schemaItem.type))) {\n                            const value = {};\n                            value.valueHex = asn1Item instanceof asn1js.Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();\n                            asn1Value.push(new asn1js.Primitive({\n                                optional: schemaItem.optional,\n                                idBlock: {\n                                    tagClass: 3,\n                                    tagNumber: schemaItem.context,\n                                },\n                                ...value,\n                            }));\n                        }\n                        else {\n                            asn1Value.push(new asn1js.Constructed({\n                                optional: schemaItem.optional,\n                                idBlock: {\n                                    tagClass: 3,\n                                    tagNumber: schemaItem.context,\n                                },\n                                value: asn1Item.valueBlock.value,\n                            }));\n                        }\n                    }\n                    else {\n                        asn1Value.push(new asn1js.Constructed({\n                            optional: schemaItem.optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: schemaItem.context,\n                            },\n                            value: [asn1Item],\n                        }));\n                    }\n                }\n                else if (schemaItem.repeated) {\n                    asn1Value = asn1Value.concat(asn1Item);\n                }\n                else {\n                    asn1Value.push(asn1Item);\n                }\n            }\n        }\n        let asnSchema;\n        switch (schema.type) {\n            case enums_1.AsnTypeTypes.Sequence:\n                asnSchema = new asn1js.Sequence({ value: asn1Value });\n                break;\n            case enums_1.AsnTypeTypes.Set:\n                asnSchema = new asn1js.Set({ value: asn1Value });\n                break;\n            case enums_1.AsnTypeTypes.Choice:\n                if (!asn1Value[0]) {\n                    throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);\n                }\n                asnSchema = asn1Value[0];\n                break;\n        }\n        return asnSchema;\n    }\n    static toAsnItem(schemaItem, key, target, objProp) {\n        let asn1Item;\n        if (typeof (schemaItem.type) === \"number\") {\n            const converter = schemaItem.converter;\n            if (!converter) {\n                throw new Error(`Property '${key}' doesn't have converter for type ${enums_1.AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);\n            }\n            if (schemaItem.repeated) {\n                if (!Array.isArray(objProp)) {\n                    throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n                }\n                const items = Array.from(objProp, (element) => converter.toASN(element));\n                const Container = schemaItem.repeated === \"sequence\"\n                    ? asn1js.Sequence\n                    : asn1js.Set;\n                asn1Item = new Container({\n                    value: items,\n                });\n            }\n            else {\n                asn1Item = converter.toASN(objProp);\n            }\n        }\n        else {\n            if (schemaItem.repeated) {\n                if (!Array.isArray(objProp)) {\n                    throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n                }\n                const items = Array.from(objProp, (element) => this.toASN(element));\n                const Container = schemaItem.repeated === \"sequence\"\n                    ? asn1js.Sequence\n                    : asn1js.Set;\n                asn1Item = new Container({\n                    value: items,\n                });\n            }\n            else {\n                asn1Item = this.toASN(objProp);\n            }\n        }\n        return asn1Item;\n    }\n}\nexports.AsnSerializer = AsnSerializer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9zZXJpYWxpemVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixlQUFlLG1CQUFPLENBQUMsMERBQVE7QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMsd0ZBQWM7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQVU7QUFDbkMsa0JBQWtCLG1CQUFPLENBQUMsa0ZBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBYTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx1QkFBdUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsSUFBSSxvQ0FBb0MsdUNBQXVDLGFBQWEsWUFBWTtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFydHVwLW5leHRqcy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3NlcmlhbGl6ZXIuanM/NzE3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNuU2VyaWFsaXplciA9IHZvaWQgMDtcbmNvbnN0IGFzbjFqcyA9IHJlcXVpcmUoXCJhc24xanNcIik7XG5jb25zdCBjb252ZXJ0ZXJzID0gcmVxdWlyZShcIi4vY29udmVydGVyc1wiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbmNvbnN0IGhlbHBlcl8xID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuY29uc3Qgc3RvcmFnZV8xID0gcmVxdWlyZShcIi4vc3RvcmFnZVwiKTtcbmNsYXNzIEFzblNlcmlhbGl6ZXIge1xuICAgIHN0YXRpYyBzZXJpYWxpemUob2JqKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBhc24xanMuQmFzZUJsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnRvQkVSKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50b0FTTihvYmopLnRvQkVSKGZhbHNlKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQVNOKG9iaikge1xuICAgICAgICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgKDAsIGhlbHBlcl8xLmlzQ29udmVydGlibGUpKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoudG9BU04oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgMSBzaG91bGQgYmUgdHlwZSBvZiBPYmplY3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuZ2V0KHRhcmdldCk7XG4gICAgICAgIHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLmNhY2hlKHRhcmdldCk7XG4gICAgICAgIGxldCBhc24xVmFsdWUgPSBbXTtcbiAgICAgICAgaWYgKHNjaGVtYS5pdGVtVHlwZSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyIDEgc2hvdWxkIGJlIHR5cGUgb2YgQXJyYXkuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuaXRlbVR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSBjb252ZXJ0ZXJzLmRlZmF1bHRDb252ZXJ0ZXIoc2NoZW1hLml0ZW1UeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnZlcnRlcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgZGVmYXVsdCBjb252ZXJ0ZXIgZm9yIGFycmF5IGl0ZW0gb2YgJHt0YXJnZXQubmFtZX0gQVNOMSBzY2hlbWFgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNuMVZhbHVlID0gb2JqLm1hcCgobykgPT4gY29udmVydGVyLnRvQVNOKG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzbjFWYWx1ZSA9IG9iai5tYXAoKG8pID0+IHRoaXMudG9Bc25JdGVtKHsgdHlwZTogc2NoZW1hLml0ZW1UeXBlIH0sIFwiW11cIiwgdGFyZ2V0LCBvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFJdGVtID0gc2NoZW1hLml0ZW1zW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqUHJvcCA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChvYmpQcm9wID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgfHwgc2NoZW1hSXRlbS5kZWZhdWx0VmFsdWUgPT09IG9ialByb3BcbiAgICAgICAgICAgICAgICAgICAgfHwgKHR5cGVvZiBzY2hlbWFJdGVtLmRlZmF1bHRWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqUHJvcCA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKDAsIGhlbHBlcl8xLmlzQXJyYXlFcXVhbCkodGhpcy5zZXJpYWxpemUoc2NoZW1hSXRlbS5kZWZhdWx0VmFsdWUpLCB0aGlzLnNlcmlhbGl6ZShvYmpQcm9wKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhc24xSXRlbSA9IEFzblNlcmlhbGl6ZXIudG9Bc25JdGVtKHNjaGVtYUl0ZW0sIGtleSwgdGFyZ2V0LCBvYmpQcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYUl0ZW0uY29udGV4dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hSXRlbS5pbXBsaWNpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWFJdGVtLnJlcGVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHR5cGVvZiBzY2hlbWFJdGVtLnR5cGUgPT09IFwibnVtYmVyXCIgfHwgKDAsIGhlbHBlcl8xLmlzQ29udmVydGlibGUpKHNjaGVtYUl0ZW0udHlwZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS52YWx1ZUhleCA9IGFzbjFJdGVtIGluc3RhbmNlb2YgYXNuMWpzLk51bGwgPyBhc24xSXRlbS52YWx1ZUJlZm9yZURlY29kZVZpZXcgOiBhc24xSXRlbS52YWx1ZUJsb2NrLnRvQkVSKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2gobmV3IGFzbjFqcy5QcmltaXRpdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogc2NoZW1hSXRlbS5vcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnQ2xhc3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IHNjaGVtYUl0ZW0uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2gobmV3IGFzbjFqcy5Db25zdHJ1Y3RlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBzY2hlbWFJdGVtLm9wdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZEJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdDbGFzczogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ051bWJlcjogc2NoZW1hSXRlbS5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXNuMUl0ZW0udmFsdWVCbG9jay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChuZXcgYXNuMWpzLkNvbnN0cnVjdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogc2NoZW1hSXRlbS5vcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZEJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0NsYXNzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IHNjaGVtYUl0ZW0uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbYXNuMUl0ZW1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtYUl0ZW0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlID0gYXNuMVZhbHVlLmNvbmNhdChhc24xSXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChhc24xSXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBhc25TY2hlbWE7XG4gICAgICAgIHN3aXRjaCAoc2NoZW1hLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgZW51bXNfMS5Bc25UeXBlVHlwZXMuU2VxdWVuY2U6XG4gICAgICAgICAgICAgICAgYXNuU2NoZW1hID0gbmV3IGFzbjFqcy5TZXF1ZW5jZSh7IHZhbHVlOiBhc24xVmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGVudW1zXzEuQXNuVHlwZVR5cGVzLlNldDpcbiAgICAgICAgICAgICAgICBhc25TY2hlbWEgPSBuZXcgYXNuMWpzLlNldCh7IHZhbHVlOiBhc24xVmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGVudW1zXzEuQXNuVHlwZVR5cGVzLkNob2ljZTpcbiAgICAgICAgICAgICAgICBpZiAoIWFzbjFWYWx1ZVswXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjaGVtYSAnJHt0YXJnZXQubmFtZX0nIGhhcyB3cm9uZyBkYXRhLiBDaG9pY2UgY2Fubm90IGJlIGVtcHR5LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc25TY2hlbWEgPSBhc24xVmFsdWVbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzblNjaGVtYTtcbiAgICB9XG4gICAgc3RhdGljIHRvQXNuSXRlbShzY2hlbWFJdGVtLCBrZXksIHRhcmdldCwgb2JqUHJvcCkge1xuICAgICAgICBsZXQgYXNuMUl0ZW07XG4gICAgICAgIGlmICh0eXBlb2YgKHNjaGVtYUl0ZW0udHlwZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IHNjaGVtYUl0ZW0uY29udmVydGVyO1xuICAgICAgICAgICAgaWYgKCFjb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3BlcnR5ICcke2tleX0nIGRvZXNuJ3QgaGF2ZSBjb252ZXJ0ZXIgZm9yIHR5cGUgJHtlbnVtc18xLkFzblByb3BUeXBlc1tzY2hlbWFJdGVtLnR5cGVdfSBpbiBzY2hlbWEgJyR7dGFyZ2V0Lm5hbWV9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYUl0ZW0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqUHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAnb2JqUHJvcCcgc2hvdWxkIGJlIHR5cGUgb2YgQXJyYXkuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IEFycmF5LmZyb20ob2JqUHJvcCwgKGVsZW1lbnQpID0+IGNvbnZlcnRlci50b0FTTihlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgQ29udGFpbmVyID0gc2NoZW1hSXRlbS5yZXBlYXRlZCA9PT0gXCJzZXF1ZW5jZVwiXG4gICAgICAgICAgICAgICAgICAgID8gYXNuMWpzLlNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgIDogYXNuMWpzLlNldDtcbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IG5ldyBDb250YWluZXIoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IGNvbnZlcnRlci50b0FTTihvYmpQcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWFJdGVtLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9ialByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ29ialByb3AnIHNob3VsZCBiZSB0eXBlIG9mIEFycmF5LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKG9ialByb3AsIChlbGVtZW50KSA9PiB0aGlzLnRvQVNOKGVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBDb250YWluZXIgPSBzY2hlbWFJdGVtLnJlcGVhdGVkID09PSBcInNlcXVlbmNlXCJcbiAgICAgICAgICAgICAgICAgICAgPyBhc24xanMuU2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgOiBhc24xanMuU2V0O1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gbmV3IENvbnRhaW5lcih7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gdGhpcy50b0FTTihvYmpQcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXNuMUl0ZW07XG4gICAgfVxufVxuZXhwb3J0cy5Bc25TZXJpYWxpemVyID0gQXNuU2VyaWFsaXplcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/storage.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.schemaStorage = void 0;\nconst schema_1 = __webpack_require__(/*! ./schema */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/schema.js\");\nexports.schemaStorage = new schema_1.AsnSchemaStorage();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9zdG9yYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBVTtBQUNuQyxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFydHVwLW5leHRqcy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3N0b3JhZ2UuanM/OWE2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2NoZW1hU3RvcmFnZSA9IHZvaWQgMDtcbmNvbnN0IHNjaGVtYV8xID0gcmVxdWlyZShcIi4vc2NoZW1hXCIpO1xuZXhwb3J0cy5zY2hlbWFTdG9yYWdlID0gbmV3IHNjaGVtYV8xLkFzblNjaGVtYVN0b3JhZ2UoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BitString = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/./node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(ssr)/./node_modules/pvtsutils/build/index.js\");\nclass BitString {\n    constructor(params, unusedBits = 0) {\n        this.unusedBits = 0;\n        this.value = new ArrayBuffer(0);\n        if (params) {\n            if (typeof params === \"number\") {\n                this.fromNumber(params);\n            }\n            else if (pvtsutils_1.BufferSourceConverter.isBufferSource(params)) {\n                this.unusedBits = unusedBits;\n                this.value = pvtsutils_1.BufferSourceConverter.toArrayBuffer(params);\n            }\n            else {\n                throw TypeError(\"Unsupported type of 'params' argument for BitString\");\n            }\n        }\n    }\n    fromASN(asn) {\n        if (!(asn instanceof asn1js.BitString)) {\n            throw new TypeError(\"Argument 'asn' is not instance of ASN.1 BitString\");\n        }\n        this.unusedBits = asn.valueBlock.unusedBits;\n        this.value = asn.valueBlock.valueHex;\n        return this;\n    }\n    toASN() {\n        return new asn1js.BitString({ unusedBits: this.unusedBits, valueHex: this.value });\n    }\n    toSchema(name) {\n        return new asn1js.BitString({ name });\n    }\n    toNumber() {\n        let res = \"\";\n        const uintArray = new Uint8Array(this.value);\n        for (const octet of uintArray) {\n            res += octet.toString(2).padStart(8, \"0\");\n        }\n        res = res.split(\"\").reverse().join(\"\");\n        if (this.unusedBits) {\n            res = res.slice(this.unusedBits).padStart(this.unusedBits, \"0\");\n        }\n        return parseInt(res, 2);\n    }\n    fromNumber(value) {\n        let bits = value.toString(2);\n        const octetSize = (bits.length + 7) >> 3;\n        this.unusedBits = (octetSize << 3) - bits.length;\n        const octets = new Uint8Array(octetSize);\n        bits = bits.padStart(octetSize << 3, \"0\").split(\"\").reverse().join(\"\");\n        let index = 0;\n        while (index < octetSize) {\n            octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);\n            index++;\n        }\n        this.value = octets.buffer;\n    }\n}\nexports.BitString = BitString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy90eXBlcy9iaXRfc3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQixlQUFlLG1CQUFPLENBQUMsMERBQVE7QUFDL0Isb0JBQW9CLG1CQUFPLENBQUMsZ0VBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtREFBbUQ7QUFDekY7QUFDQTtBQUNBLHNDQUFzQyxNQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YXJ0dXAtbmV4dGpzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvdHlwZXMvYml0X3N0cmluZy5qcz9iNmQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaXRTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBhc24xanMgPSByZXF1aXJlKFwiYXNuMWpzXCIpO1xuY29uc3QgcHZ0c3V0aWxzXzEgPSByZXF1aXJlKFwicHZ0c3V0aWxzXCIpO1xuY2xhc3MgQml0U3RyaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMsIHVudXNlZEJpdHMgPSAwKSB7XG4gICAgICAgIHRoaXMudW51c2VkQml0cyA9IDA7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tTnVtYmVyKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwdnRzdXRpbHNfMS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIuaXNCdWZmZXJTb3VyY2UocGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW51c2VkQml0cyA9IHVudXNlZEJpdHM7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHB2dHN1dGlsc18xLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIG9mICdwYXJhbXMnIGFyZ3VtZW50IGZvciBCaXRTdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbUFTTihhc24pIHtcbiAgICAgICAgaWYgKCEoYXNuIGluc3RhbmNlb2YgYXNuMWpzLkJpdFN0cmluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCAnYXNuJyBpcyBub3QgaW5zdGFuY2Ugb2YgQVNOLjEgQml0U3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW51c2VkQml0cyA9IGFzbi52YWx1ZUJsb2NrLnVudXNlZEJpdHM7XG4gICAgICAgIHRoaXMudmFsdWUgPSBhc24udmFsdWVCbG9jay52YWx1ZUhleDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvQVNOKCkge1xuICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5CaXRTdHJpbmcoeyB1bnVzZWRCaXRzOiB0aGlzLnVudXNlZEJpdHMsIHZhbHVlSGV4OiB0aGlzLnZhbHVlIH0pO1xuICAgIH1cbiAgICB0b1NjaGVtYShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgYXNuMWpzLkJpdFN0cmluZyh7IG5hbWUgfSk7XG4gICAgfVxuICAgIHRvTnVtYmVyKCkge1xuICAgICAgICBsZXQgcmVzID0gXCJcIjtcbiAgICAgICAgY29uc3QgdWludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy52YWx1ZSk7XG4gICAgICAgIGZvciAoY29uc3Qgb2N0ZXQgb2YgdWludEFycmF5KSB7XG4gICAgICAgICAgICByZXMgKz0gb2N0ZXQudG9TdHJpbmcoMikucGFkU3RhcnQoOCwgXCIwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IHJlcy5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICAgICAgaWYgKHRoaXMudW51c2VkQml0cykge1xuICAgICAgICAgICAgcmVzID0gcmVzLnNsaWNlKHRoaXMudW51c2VkQml0cykucGFkU3RhcnQodGhpcy51bnVzZWRCaXRzLCBcIjBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHJlcywgMik7XG4gICAgfVxuICAgIGZyb21OdW1iZXIodmFsdWUpIHtcbiAgICAgICAgbGV0IGJpdHMgPSB2YWx1ZS50b1N0cmluZygyKTtcbiAgICAgICAgY29uc3Qgb2N0ZXRTaXplID0gKGJpdHMubGVuZ3RoICsgNykgPj4gMztcbiAgICAgICAgdGhpcy51bnVzZWRCaXRzID0gKG9jdGV0U2l6ZSA8PCAzKSAtIGJpdHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBvY3RldHMgPSBuZXcgVWludDhBcnJheShvY3RldFNpemUpO1xuICAgICAgICBiaXRzID0gYml0cy5wYWRTdGFydChvY3RldFNpemUgPDwgMywgXCIwXCIpLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBvY3RldFNpemUpIHtcbiAgICAgICAgICAgIG9jdGV0c1tpbmRleF0gPSBwYXJzZUludChiaXRzLnNsaWNlKGluZGV4IDw8IDMsIChpbmRleCA8PCAzKSArIDgpLCAyKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IG9jdGV0cy5idWZmZXI7XG4gICAgfVxufVxuZXhwb3J0cy5CaXRTdHJpbmcgPSBCaXRTdHJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\ntslib_1.__exportStar(__webpack_require__(/*! ./bit_string */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./octet_string */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy90eXBlcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsbUJBQU8sQ0FBQyx1REFBTztBQUMvQixxQkFBcUIsbUJBQU8sQ0FBQyw4RkFBYztBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyxrR0FBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFydHVwLW5leHRqcy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3R5cGVzL2luZGV4LmpzP2NmNDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYml0X3N0cmluZ1wiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vY3RldF9zdHJpbmdcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OctetString = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/./node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(ssr)/./node_modules/pvtsutils/build/index.js\");\nclass OctetString {\n    get byteLength() {\n        return this.buffer.byteLength;\n    }\n    get byteOffset() {\n        return 0;\n    }\n    constructor(param) {\n        if (typeof param === \"number\") {\n            this.buffer = new ArrayBuffer(param);\n        }\n        else {\n            if (pvtsutils_1.BufferSourceConverter.isBufferSource(param)) {\n                this.buffer = pvtsutils_1.BufferSourceConverter.toArrayBuffer(param);\n            }\n            else if (Array.isArray(param)) {\n                this.buffer = new Uint8Array(param);\n            }\n            else {\n                this.buffer = new ArrayBuffer(0);\n            }\n        }\n    }\n    fromASN(asn) {\n        if (!(asn instanceof asn1js.OctetString)) {\n            throw new TypeError(\"Argument 'asn' is not instance of ASN.1 OctetString\");\n        }\n        this.buffer = asn.valueBlock.valueHex;\n        return this;\n    }\n    toASN() {\n        return new asn1js.OctetString({ valueHex: this.buffer });\n    }\n    toSchema(name) {\n        return new asn1js.OctetString({ name });\n    }\n}\nexports.OctetString = OctetString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy90eXBlcy9vY3RldF9zdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLGVBQWUsbUJBQU8sQ0FBQywwREFBUTtBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQyxnRUFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1QkFBdUI7QUFDL0Q7QUFDQTtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFydHVwLW5leHRqcy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3R5cGVzL29jdGV0X3N0cmluZy5qcz8zMGZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PY3RldFN0cmluZyA9IHZvaWQgMDtcbmNvbnN0IGFzbjFqcyA9IHJlcXVpcmUoXCJhc24xanNcIik7XG5jb25zdCBwdnRzdXRpbHNfMSA9IHJlcXVpcmUoXCJwdnRzdXRpbHNcIik7XG5jbGFzcyBPY3RldFN0cmluZyB7XG4gICAgZ2V0IGJ5dGVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgYnl0ZU9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBhcmFtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwdnRzdXRpbHNfMS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIuaXNCdWZmZXJTb3VyY2UocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBwdnRzdXRpbHNfMS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihwYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcmFtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkocGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbUFTTihhc24pIHtcbiAgICAgICAgaWYgKCEoYXNuIGluc3RhbmNlb2YgYXNuMWpzLk9jdGV0U3RyaW5nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50ICdhc24nIGlzIG5vdCBpbnN0YW5jZSBvZiBBU04uMSBPY3RldFN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IGFzbi52YWx1ZUJsb2NrLnZhbHVlSGV4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9BU04oKSB7XG4gICAgICAgIHJldHVybiBuZXcgYXNuMWpzLk9jdGV0U3RyaW5nKHsgdmFsdWVIZXg6IHRoaXMuYnVmZmVyIH0pO1xuICAgIH1cbiAgICB0b1NjaGVtYShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgYXNuMWpzLk9jdGV0U3RyaW5nKHsgbmFtZSB9KTtcbiAgICB9XG59XG5leHBvcnRzLk9jdGV0U3RyaW5nID0gT2N0ZXRTdHJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/json-schema/build/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@peculiar/json-schema/build/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Copyright (c) 2020, Peculiar Ventures, All rights reserved.\n */\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nclass JsonError extends Error {\r\n    constructor(message, innerError) {\r\n        super(innerError\r\n            ? `${message}. See the inner exception for more details.`\r\n            : message);\r\n        this.message = message;\r\n        this.innerError = innerError;\r\n    }\r\n}\n\nclass TransformError extends JsonError {\r\n    constructor(schema, message, innerError) {\r\n        super(message, innerError);\r\n        this.schema = schema;\r\n    }\r\n}\n\nclass ParserError extends TransformError {\r\n    constructor(schema, message, innerError) {\r\n        super(schema, `JSON doesn't match to '${schema.target.name}' schema. ${message}`, innerError);\r\n    }\r\n}\n\nclass ValidationError extends JsonError {\r\n}\n\nclass SerializerError extends JsonError {\r\n    constructor(schemaName, message, innerError) {\r\n        super(`Cannot serialize by '${schemaName}' schema. ${message}`, innerError);\r\n        this.schemaName = schemaName;\r\n    }\r\n}\n\nclass KeyError extends ParserError {\r\n    constructor(schema, keys, errors = {}) {\r\n        super(schema, \"Some keys doesn't match to schema\");\r\n        this.keys = keys;\r\n        this.errors = errors;\r\n    }\r\n}\n\n(function (JsonPropTypes) {\r\n    JsonPropTypes[JsonPropTypes[\"Any\"] = 0] = \"Any\";\r\n    JsonPropTypes[JsonPropTypes[\"Boolean\"] = 1] = \"Boolean\";\r\n    JsonPropTypes[JsonPropTypes[\"Number\"] = 2] = \"Number\";\r\n    JsonPropTypes[JsonPropTypes[\"String\"] = 3] = \"String\";\r\n})(exports.JsonPropTypes || (exports.JsonPropTypes = {}));\n\nfunction checkType(value, type) {\r\n    switch (type) {\r\n        case exports.JsonPropTypes.Boolean:\r\n            return typeof value === \"boolean\";\r\n        case exports.JsonPropTypes.Number:\r\n            return typeof value === \"number\";\r\n        case exports.JsonPropTypes.String:\r\n            return typeof value === \"string\";\r\n    }\r\n    return true;\r\n}\r\nfunction throwIfTypeIsWrong(value, type) {\r\n    if (!checkType(value, type)) {\r\n        throw new TypeError(`Value must be ${exports.JsonPropTypes[type]}`);\r\n    }\r\n}\r\nfunction isConvertible(target) {\r\n    if (target && target.prototype) {\r\n        if (target.prototype.toJSON && target.prototype.fromJSON) {\r\n            return true;\r\n        }\r\n        else {\r\n            return isConvertible(target.prototype);\r\n        }\r\n    }\r\n    else {\r\n        return !!(target && target.toJSON && target.fromJSON);\r\n    }\r\n}\n\nclass JsonSchemaStorage {\r\n    constructor() {\r\n        this.items = new Map();\r\n    }\r\n    has(target) {\r\n        return this.items.has(target) || !!this.findParentSchema(target);\r\n    }\r\n    get(target) {\r\n        const schema = this.items.get(target) || this.findParentSchema(target);\r\n        if (!schema) {\r\n            throw new Error(\"Cannot get schema for current target\");\r\n        }\r\n        return schema;\r\n    }\r\n    create(target) {\r\n        const schema = { names: {} };\r\n        const parentSchema = this.findParentSchema(target);\r\n        if (parentSchema) {\r\n            Object.assign(schema, parentSchema);\r\n            schema.names = {};\r\n            for (const name in parentSchema.names) {\r\n                schema.names[name] = Object.assign({}, parentSchema.names[name]);\r\n            }\r\n        }\r\n        schema.target = target;\r\n        return schema;\r\n    }\r\n    set(target, schema) {\r\n        this.items.set(target, schema);\r\n        return this;\r\n    }\r\n    findParentSchema(target) {\r\n        const parent = target.__proto__;\r\n        if (parent) {\r\n            const schema = this.items.get(parent);\r\n            return schema || this.findParentSchema(parent);\r\n        }\r\n        return null;\r\n    }\r\n}\n\nconst DEFAULT_SCHEMA = \"default\";\r\nconst schemaStorage = new JsonSchemaStorage();\n\nclass PatternValidation {\r\n    constructor(pattern) {\r\n        this.pattern = new RegExp(pattern);\r\n    }\r\n    validate(value) {\r\n        const pattern = new RegExp(this.pattern.source, this.pattern.flags);\r\n        if (typeof value !== \"string\") {\r\n            throw new ValidationError(\"Incoming value must be string\");\r\n        }\r\n        if (!pattern.exec(value)) {\r\n            throw new ValidationError(`Value doesn't match to pattern '${pattern.toString()}'`);\r\n        }\r\n    }\r\n}\n\nclass InclusiveValidation {\r\n    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    validate(value) {\r\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.Number);\r\n        if (!(this.min <= value && value <= this.max)) {\r\n            const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\r\n            const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\r\n            throw new ValidationError(`Value doesn't match to diapason [${min},${max}]`);\r\n        }\r\n    }\r\n}\n\nclass ExclusiveValidation {\r\n    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    validate(value) {\r\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.Number);\r\n        if (!(this.min < value && value < this.max)) {\r\n            const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\r\n            const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\r\n            throw new ValidationError(`Value doesn't match to diapason (${min},${max})`);\r\n        }\r\n    }\r\n}\n\nclass LengthValidation {\r\n    constructor(length, minLength, maxLength) {\r\n        this.length = length;\r\n        this.minLength = minLength;\r\n        this.maxLength = maxLength;\r\n    }\r\n    validate(value) {\r\n        if (this.length !== undefined) {\r\n            if (value.length !== this.length) {\r\n                throw new ValidationError(`Value length must be exactly ${this.length}.`);\r\n            }\r\n            return;\r\n        }\r\n        if (this.minLength !== undefined) {\r\n            if (value.length < this.minLength) {\r\n                throw new ValidationError(`Value length must be more than ${this.minLength}.`);\r\n            }\r\n        }\r\n        if (this.maxLength !== undefined) {\r\n            if (value.length > this.maxLength) {\r\n                throw new ValidationError(`Value length must be less than ${this.maxLength}.`);\r\n            }\r\n        }\r\n    }\r\n}\n\nclass EnumerationValidation {\r\n    constructor(enumeration) {\r\n        this.enumeration = enumeration;\r\n    }\r\n    validate(value) {\r\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.String);\r\n        if (!this.enumeration.includes(value)) {\r\n            throw new ValidationError(`Value must be one of ${this.enumeration.map((v) => `'${v}'`).join(\", \")}`);\r\n        }\r\n    }\r\n}\n\nclass JsonTransform {\r\n    static checkValues(data, schemaItem) {\r\n        const values = Array.isArray(data) ? data : [data];\r\n        for (const value of values) {\r\n            for (const validation of schemaItem.validations) {\r\n                if (validation instanceof LengthValidation && schemaItem.repeated) {\r\n                    validation.validate(data);\r\n                }\r\n                else {\r\n                    validation.validate(value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static checkTypes(value, schemaItem) {\r\n        if (schemaItem.repeated && !Array.isArray(value)) {\r\n            throw new TypeError(\"Value must be Array\");\r\n        }\r\n        if (typeof schemaItem.type === \"number\") {\r\n            const values = Array.isArray(value) ? value : [value];\r\n            for (const v of values) {\r\n                throwIfTypeIsWrong(v, schemaItem.type);\r\n            }\r\n        }\r\n    }\r\n    static getSchemaByName(schema, name = DEFAULT_SCHEMA) {\r\n        return { ...schema.names[DEFAULT_SCHEMA], ...schema.names[name] };\r\n    }\r\n}\n\nclass JsonSerializer extends JsonTransform {\r\n    static serialize(obj, options, replacer, space) {\r\n        const json = this.toJSON(obj, options);\r\n        return JSON.stringify(json, replacer, space);\r\n    }\r\n    static toJSON(obj, options = {}) {\r\n        let res;\r\n        let targetSchema = options.targetSchema;\r\n        const schemaName = options.schemaName || DEFAULT_SCHEMA;\r\n        if (isConvertible(obj)) {\r\n            return obj.toJSON();\r\n        }\r\n        if (Array.isArray(obj)) {\r\n            res = [];\r\n            for (const item of obj) {\r\n                res.push(this.toJSON(item, options));\r\n            }\r\n        }\r\n        else if (typeof obj === \"object\") {\r\n            if (targetSchema && !schemaStorage.has(targetSchema)) {\r\n                throw new JsonError(\"Cannot get schema for `targetSchema` param\");\r\n            }\r\n            targetSchema = (targetSchema || obj.constructor);\r\n            if (schemaStorage.has(targetSchema)) {\r\n                const schema = schemaStorage.get(targetSchema);\r\n                res = {};\r\n                const namedSchema = this.getSchemaByName(schema, schemaName);\r\n                for (const key in namedSchema) {\r\n                    try {\r\n                        const item = namedSchema[key];\r\n                        const objItem = obj[key];\r\n                        let value;\r\n                        if ((item.optional && objItem === undefined)\r\n                            || (item.defaultValue !== undefined && objItem === item.defaultValue)) {\r\n                            continue;\r\n                        }\r\n                        if (!item.optional && objItem === undefined) {\r\n                            throw new SerializerError(targetSchema.name, `Property '${key}' is required.`);\r\n                        }\r\n                        if (typeof item.type === \"number\") {\r\n                            if (item.converter) {\r\n                                if (item.repeated) {\r\n                                    value = objItem.map((el) => item.converter.toJSON(el, obj));\r\n                                }\r\n                                else {\r\n                                    value = item.converter.toJSON(objItem, obj);\r\n                                }\r\n                            }\r\n                            else {\r\n                                value = objItem;\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (item.repeated) {\r\n                                value = objItem.map((el) => this.toJSON(el, { schemaName }));\r\n                            }\r\n                            else {\r\n                                value = this.toJSON(objItem, { schemaName });\r\n                            }\r\n                        }\r\n                        this.checkTypes(value, item);\r\n                        this.checkValues(value, item);\r\n                        res[item.name || key] = value;\r\n                    }\r\n                    catch (e) {\r\n                        if (e instanceof SerializerError) {\r\n                            throw e;\r\n                        }\r\n                        else {\r\n                            throw new SerializerError(schema.target.name, `Property '${key}' is wrong. ${e.message}`, e);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                res = {};\r\n                for (const key in obj) {\r\n                    res[key] = this.toJSON(obj[key], { schemaName });\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            res = obj;\r\n        }\r\n        return res;\r\n    }\r\n}\n\nclass JsonParser extends JsonTransform {\r\n    static parse(data, options) {\r\n        const obj = JSON.parse(data);\r\n        return this.fromJSON(obj, options);\r\n    }\r\n    static fromJSON(target, options) {\r\n        const targetSchema = options.targetSchema;\r\n        const schemaName = options.schemaName || DEFAULT_SCHEMA;\r\n        const obj = new targetSchema();\r\n        if (isConvertible(obj)) {\r\n            return obj.fromJSON(target);\r\n        }\r\n        const schema = schemaStorage.get(targetSchema);\r\n        const namedSchema = this.getSchemaByName(schema, schemaName);\r\n        const keyErrors = {};\r\n        if (options.strictProperty && !Array.isArray(target)) {\r\n            JsonParser.checkStrictProperty(target, namedSchema, schema);\r\n        }\r\n        for (const key in namedSchema) {\r\n            try {\r\n                const item = namedSchema[key];\r\n                const name = item.name || key;\r\n                const value = target[name];\r\n                if (value === undefined && (item.optional || item.defaultValue !== undefined)) {\r\n                    continue;\r\n                }\r\n                if (!item.optional && value === undefined) {\r\n                    throw new ParserError(schema, `Property '${name}' is required.`);\r\n                }\r\n                this.checkTypes(value, item);\r\n                this.checkValues(value, item);\r\n                if (typeof (item.type) === \"number\") {\r\n                    if (item.converter) {\r\n                        if (item.repeated) {\r\n                            obj[key] = value.map((el) => item.converter.fromJSON(el, obj));\r\n                        }\r\n                        else {\r\n                            obj[key] = item.converter.fromJSON(value, obj);\r\n                        }\r\n                    }\r\n                    else {\r\n                        obj[key] = value;\r\n                    }\r\n                }\r\n                else {\r\n                    const newOptions = {\r\n                        ...options,\r\n                        targetSchema: item.type,\r\n                        schemaName,\r\n                    };\r\n                    if (item.repeated) {\r\n                        obj[key] = value.map((el) => this.fromJSON(el, newOptions));\r\n                    }\r\n                    else {\r\n                        obj[key] = this.fromJSON(value, newOptions);\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n                if (!(e instanceof ParserError)) {\r\n                    e = new ParserError(schema, `Property '${key}' is wrong. ${e.message}`, e);\r\n                }\r\n                if (options.strictAllKeys) {\r\n                    keyErrors[key] = e;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        const keys = Object.keys(keyErrors);\r\n        if (keys.length) {\r\n            throw new KeyError(schema, keys, keyErrors);\r\n        }\r\n        return obj;\r\n    }\r\n    static checkStrictProperty(target, namedSchema, schema) {\r\n        const jsonProps = Object.keys(target);\r\n        const schemaProps = Object.keys(namedSchema);\r\n        const keys = [];\r\n        for (const key of jsonProps) {\r\n            if (schemaProps.indexOf(key) === -1) {\r\n                keys.push(key);\r\n            }\r\n        }\r\n        if (keys.length) {\r\n            throw new KeyError(schema, keys);\r\n        }\r\n    }\r\n}\n\nfunction getValidations(item) {\r\n    const validations = [];\r\n    if (item.pattern) {\r\n        validations.push(new PatternValidation(item.pattern));\r\n    }\r\n    if (item.type === exports.JsonPropTypes.Number || item.type === exports.JsonPropTypes.Any) {\r\n        if (item.minInclusive !== undefined || item.maxInclusive !== undefined) {\r\n            validations.push(new InclusiveValidation(item.minInclusive, item.maxInclusive));\r\n        }\r\n        if (item.minExclusive !== undefined || item.maxExclusive !== undefined) {\r\n            validations.push(new ExclusiveValidation(item.minExclusive, item.maxExclusive));\r\n        }\r\n        if (item.enumeration !== undefined) {\r\n            validations.push(new EnumerationValidation(item.enumeration));\r\n        }\r\n    }\r\n    if (item.type === exports.JsonPropTypes.String || item.repeated || item.type === exports.JsonPropTypes.Any) {\r\n        if (item.length !== undefined || item.minLength !== undefined || item.maxLength !== undefined) {\r\n            validations.push(new LengthValidation(item.length, item.minLength, item.maxLength));\r\n        }\r\n    }\r\n    return validations;\r\n}\r\nconst JsonProp = (options = {}) => (target, propertyKey) => {\r\n    const errorMessage = `Cannot set type for ${propertyKey} property of ${target.constructor.name} schema`;\r\n    let schema;\r\n    if (!schemaStorage.has(target.constructor)) {\r\n        schema = schemaStorage.create(target.constructor);\r\n        schemaStorage.set(target.constructor, schema);\r\n    }\r\n    else {\r\n        schema = schemaStorage.get(target.constructor);\r\n        if (schema.target !== target.constructor) {\r\n            schema = schemaStorage.create(target.constructor);\r\n            schemaStorage.set(target.constructor, schema);\r\n        }\r\n    }\r\n    const defaultSchema = {\r\n        type: exports.JsonPropTypes.Any,\r\n        validations: [],\r\n    };\r\n    const copyOptions = Object.assign(defaultSchema, options);\r\n    copyOptions.validations = getValidations(copyOptions);\r\n    if (typeof copyOptions.type !== \"number\") {\r\n        if (!schemaStorage.has(copyOptions.type) && !isConvertible(copyOptions.type)) {\r\n            throw new Error(`${errorMessage}. Assigning type doesn't have schema.`);\r\n        }\r\n    }\r\n    let schemaNames;\r\n    if (Array.isArray(options.schema)) {\r\n        schemaNames = options.schema;\r\n    }\r\n    else {\r\n        schemaNames = [options.schema || DEFAULT_SCHEMA];\r\n    }\r\n    for (const schemaName of schemaNames) {\r\n        if (!schema.names[schemaName]) {\r\n            schema.names[schemaName] = {};\r\n        }\r\n        const namedSchema = schema.names[schemaName];\r\n        namedSchema[propertyKey] = copyOptions;\r\n    }\r\n};\n\nexports.JsonError = JsonError;\nexports.JsonParser = JsonParser;\nexports.JsonProp = JsonProp;\nexports.JsonSerializer = JsonSerializer;\nexports.KeyError = KeyError;\nexports.ParserError = ParserError;\nexports.SerializerError = SerializerError;\nexports.TransformError = TransformError;\nexports.ValidationError = ValidationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2pzb24tc2NoZW1hL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsbUJBQW1CLFlBQVksUUFBUTtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxXQUFXLFlBQVksUUFBUTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEIscUJBQXFCLEtBQUs7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDRCQUE0QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsbUJBQW1CO0FBQzVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxJQUFJLEdBQUcsSUFBSTtBQUNyRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsSUFBSSxHQUFHLElBQUk7QUFDckY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxZQUFZO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsZUFBZTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxlQUFlO0FBQzNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdDQUFnQyxFQUFFLGVBQWU7QUFDL0c7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLElBQUk7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsWUFBWTtBQUMxRjtBQUNBO0FBQ0EsK0RBQStELFlBQVk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixJQUFJLGNBQWMsVUFBVTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxZQUFZO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsS0FBSztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELElBQUksY0FBYyxVQUFVO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixnREFBZ0QsYUFBYSxjQUFjLHlCQUF5QjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixzQkFBc0I7QUFDdEIsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLHVCQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YXJ0dXAtbmV4dGpzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9qc29uLXNjaGVtYS9idWlsZC9pbmRleC5qcz82ZWVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDIwLCBQZWN1bGlhciBWZW50dXJlcywgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNsYXNzIEpzb25FcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGlubmVyRXJyb3IpIHtcclxuICAgICAgICBzdXBlcihpbm5lckVycm9yXHJcbiAgICAgICAgICAgID8gYCR7bWVzc2FnZX0uIFNlZSB0aGUgaW5uZXIgZXhjZXB0aW9uIGZvciBtb3JlIGRldGFpbHMuYFxyXG4gICAgICAgICAgICA6IG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgdGhpcy5pbm5lckVycm9yID0gaW5uZXJFcnJvcjtcclxuICAgIH1cclxufVxuXG5jbGFzcyBUcmFuc2Zvcm1FcnJvciBleHRlbmRzIEpzb25FcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIG1lc3NhZ2UsIGlubmVyRXJyb3IpIHtcclxuICAgICAgICBzdXBlcihtZXNzYWdlLCBpbm5lckVycm9yKTtcclxuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBQYXJzZXJFcnJvciBleHRlbmRzIFRyYW5zZm9ybUVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSwgbWVzc2FnZSwgaW5uZXJFcnJvcikge1xyXG4gICAgICAgIHN1cGVyKHNjaGVtYSwgYEpTT04gZG9lc24ndCBtYXRjaCB0byAnJHtzY2hlbWEudGFyZ2V0Lm5hbWV9JyBzY2hlbWEuICR7bWVzc2FnZX1gLCBpbm5lckVycm9yKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBKc29uRXJyb3Ige1xyXG59XG5cbmNsYXNzIFNlcmlhbGl6ZXJFcnJvciBleHRlbmRzIEpzb25FcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWFOYW1lLCBtZXNzYWdlLCBpbm5lckVycm9yKSB7XHJcbiAgICAgICAgc3VwZXIoYENhbm5vdCBzZXJpYWxpemUgYnkgJyR7c2NoZW1hTmFtZX0nIHNjaGVtYS4gJHttZXNzYWdlfWAsIGlubmVyRXJyb3IpO1xyXG4gICAgICAgIHRoaXMuc2NoZW1hTmFtZSA9IHNjaGVtYU5hbWU7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgS2V5RXJyb3IgZXh0ZW5kcyBQYXJzZXJFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIGtleXMsIGVycm9ycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIoc2NoZW1hLCBcIlNvbWUga2V5cyBkb2Vzbid0IG1hdGNoIHRvIHNjaGVtYVwiKTtcclxuICAgICAgICB0aGlzLmtleXMgPSBrZXlzO1xyXG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xyXG4gICAgfVxyXG59XG5cbihmdW5jdGlvbiAoSnNvblByb3BUeXBlcykge1xyXG4gICAgSnNvblByb3BUeXBlc1tKc29uUHJvcFR5cGVzW1wiQW55XCJdID0gMF0gPSBcIkFueVwiO1xyXG4gICAgSnNvblByb3BUeXBlc1tKc29uUHJvcFR5cGVzW1wiQm9vbGVhblwiXSA9IDFdID0gXCJCb29sZWFuXCI7XHJcbiAgICBKc29uUHJvcFR5cGVzW0pzb25Qcm9wVHlwZXNbXCJOdW1iZXJcIl0gPSAyXSA9IFwiTnVtYmVyXCI7XHJcbiAgICBKc29uUHJvcFR5cGVzW0pzb25Qcm9wVHlwZXNbXCJTdHJpbmdcIl0gPSAzXSA9IFwiU3RyaW5nXCI7XHJcbn0pKGV4cG9ydHMuSnNvblByb3BUeXBlcyB8fCAoZXhwb3J0cy5Kc29uUHJvcFR5cGVzID0ge30pKTtcblxuZnVuY3Rpb24gY2hlY2tUeXBlKHZhbHVlLCB0eXBlKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIGV4cG9ydHMuSnNvblByb3BUeXBlcy5Cb29sZWFuOlxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIjtcclxuICAgICAgICBjYXNlIGV4cG9ydHMuSnNvblByb3BUeXBlcy5OdW1iZXI6XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XHJcbiAgICAgICAgY2FzZSBleHBvcnRzLkpzb25Qcm9wVHlwZXMuU3RyaW5nOlxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gdGhyb3dJZlR5cGVJc1dyb25nKHZhbHVlLCB0eXBlKSB7XHJcbiAgICBpZiAoIWNoZWNrVHlwZSh2YWx1ZSwgdHlwZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBWYWx1ZSBtdXN0IGJlICR7ZXhwb3J0cy5Kc29uUHJvcFR5cGVzW3R5cGVdfWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzQ29udmVydGlibGUodGFyZ2V0KSB7XHJcbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5wcm90b3R5cGUpIHtcclxuICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZS50b0pTT04gJiYgdGFyZ2V0LnByb3RvdHlwZS5mcm9tSlNPTikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0NvbnZlcnRpYmxlKHRhcmdldC5wcm90b3R5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAhISh0YXJnZXQgJiYgdGFyZ2V0LnRvSlNPTiAmJiB0YXJnZXQuZnJvbUpTT04pO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEpzb25TY2hlbWFTdG9yYWdlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuaXRlbXMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBoYXModGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuaGFzKHRhcmdldCkgfHwgISF0aGlzLmZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KTtcclxuICAgIH1cclxuICAgIGdldCh0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLml0ZW1zLmdldCh0YXJnZXQpIHx8IHRoaXMuZmluZFBhcmVudFNjaGVtYSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghc2NoZW1hKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgc2NoZW1hIGZvciBjdXJyZW50IHRhcmdldFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcclxuICAgIH1cclxuICAgIGNyZWF0ZSh0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCBzY2hlbWEgPSB7IG5hbWVzOiB7fSB9O1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFNjaGVtYSA9IHRoaXMuZmluZFBhcmVudFNjaGVtYSh0YXJnZXQpO1xyXG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzY2hlbWEsIHBhcmVudFNjaGVtYSk7XHJcbiAgICAgICAgICAgIHNjaGVtYS5uYW1lcyA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gcGFyZW50U2NoZW1hLm5hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBzY2hlbWEubmFtZXNbbmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRTY2hlbWEubmFtZXNbbmFtZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjaGVtYS50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcclxuICAgIH1cclxuICAgIHNldCh0YXJnZXQsIHNjaGVtYSkge1xyXG4gICAgICAgIHRoaXMuaXRlbXMuc2V0KHRhcmdldCwgc2NoZW1hKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGFyZ2V0Ll9fcHJvdG9fXztcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuaXRlbXMuZ2V0KHBhcmVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEgfHwgdGhpcy5maW5kUGFyZW50U2NoZW1hKHBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IERFRkFVTFRfU0NIRU1BID0gXCJkZWZhdWx0XCI7XHJcbmNvbnN0IHNjaGVtYVN0b3JhZ2UgPSBuZXcgSnNvblNjaGVtYVN0b3JhZ2UoKTtcblxuY2xhc3MgUGF0dGVyblZhbGlkYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IocGF0dGVybikge1xyXG4gICAgICAgIHRoaXMucGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybik7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKHRoaXMucGF0dGVybi5zb3VyY2UsIHRoaXMucGF0dGVybi5mbGFncyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiSW5jb21pbmcgdmFsdWUgbXVzdCBiZSBzdHJpbmdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcGF0dGVybi5leGVjKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBWYWx1ZSBkb2Vzbid0IG1hdGNoIHRvIHBhdHRlcm4gJyR7cGF0dGVybi50b1N0cmluZygpfSdgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSW5jbHVzaXZlVmFsaWRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihtaW4gPSBOdW1iZXIuTUlOX1ZBTFVFLCBtYXggPSBOdW1iZXIuTUFYX1ZBTFVFKSB7XHJcbiAgICAgICAgdGhpcy5taW4gPSBtaW47XHJcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIHRocm93SWZUeXBlSXNXcm9uZyh2YWx1ZSwgZXhwb3J0cy5Kc29uUHJvcFR5cGVzLk51bWJlcik7XHJcbiAgICAgICAgaWYgKCEodGhpcy5taW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gdGhpcy5tYXgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbiA9IHRoaXMubWluID09PSBOdW1iZXIuTUlOX1ZBTFVFID8gXCJNSU5cIiA6IHRoaXMubWluO1xyXG4gICAgICAgICAgICBjb25zdCBtYXggPSB0aGlzLm1heCA9PT0gTnVtYmVyLk1BWF9WQUxVRSA/IFwiTUFYXCIgOiB0aGlzLm1heDtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgZG9lc24ndCBtYXRjaCB0byBkaWFwYXNvbiBbJHttaW59LCR7bWF4fV1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRXhjbHVzaXZlVmFsaWRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihtaW4gPSBOdW1iZXIuTUlOX1ZBTFVFLCBtYXggPSBOdW1iZXIuTUFYX1ZBTFVFKSB7XHJcbiAgICAgICAgdGhpcy5taW4gPSBtaW47XHJcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIHRocm93SWZUeXBlSXNXcm9uZyh2YWx1ZSwgZXhwb3J0cy5Kc29uUHJvcFR5cGVzLk51bWJlcik7XHJcbiAgICAgICAgaWYgKCEodGhpcy5taW4gPCB2YWx1ZSAmJiB2YWx1ZSA8IHRoaXMubWF4KSkge1xyXG4gICAgICAgICAgICBjb25zdCBtaW4gPSB0aGlzLm1pbiA9PT0gTnVtYmVyLk1JTl9WQUxVRSA/IFwiTUlOXCIgOiB0aGlzLm1pbjtcclxuICAgICAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5tYXggPT09IE51bWJlci5NQVhfVkFMVUUgPyBcIk1BWFwiIDogdGhpcy5tYXg7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIGRvZXNuJ3QgbWF0Y2ggdG8gZGlhcGFzb24gKCR7bWlufSwke21heH0pYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIExlbmd0aFZhbGlkYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBtaW5MZW5ndGgsIG1heExlbmd0aCkge1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICAgIHRoaXMubWluTGVuZ3RoID0gbWluTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSB0aGlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgbGVuZ3RoIG11c3QgYmUgZXhhY3RseSAke3RoaXMubGVuZ3RofS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPCB0aGlzLm1pbkxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgbGVuZ3RoIG11c3QgYmUgbW9yZSB0aGFuICR7dGhpcy5taW5MZW5ndGh9LmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1heExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiB0aGlzLm1heExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgbGVuZ3RoIG11c3QgYmUgbGVzcyB0aGFuICR7dGhpcy5tYXhMZW5ndGh9LmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEVudW1lcmF0aW9uVmFsaWRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnVtZXJhdGlvbikge1xyXG4gICAgICAgIHRoaXMuZW51bWVyYXRpb24gPSBlbnVtZXJhdGlvbjtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhyb3dJZlR5cGVJc1dyb25nKHZhbHVlLCBleHBvcnRzLkpzb25Qcm9wVHlwZXMuU3RyaW5nKTtcclxuICAgICAgICBpZiAoIXRoaXMuZW51bWVyYXRpb24uaW5jbHVkZXModmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIG11c3QgYmUgb25lIG9mICR7dGhpcy5lbnVtZXJhdGlvbi5tYXAoKHYpID0+IGAnJHt2fSdgKS5qb2luKFwiLCBcIil9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEpzb25UcmFuc2Zvcm0ge1xyXG4gICAgc3RhdGljIGNoZWNrVmFsdWVzKGRhdGEsIHNjaGVtYUl0ZW0pIHtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YSA6IFtkYXRhXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbGlkYXRpb24gb2Ygc2NoZW1hSXRlbS52YWxpZGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb24gaW5zdGFuY2VvZiBMZW5ndGhWYWxpZGF0aW9uICYmIHNjaGVtYUl0ZW0ucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uLnZhbGlkYXRlKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbi52YWxpZGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY2hlY2tUeXBlcyh2YWx1ZSwgc2NoZW1hSXRlbSkge1xyXG4gICAgICAgIGlmIChzY2hlbWFJdGVtLnJlcGVhdGVkICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVmFsdWUgbXVzdCBiZSBBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFJdGVtLnR5cGUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93SWZUeXBlSXNXcm9uZyh2LCBzY2hlbWFJdGVtLnR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFNjaGVtYUJ5TmFtZShzY2hlbWEsIG5hbWUgPSBERUZBVUxUX1NDSEVNQSkge1xyXG4gICAgICAgIHJldHVybiB7IC4uLnNjaGVtYS5uYW1lc1tERUZBVUxUX1NDSEVNQV0sIC4uLnNjaGVtYS5uYW1lc1tuYW1lXSB9O1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEpzb25TZXJpYWxpemVyIGV4dGVuZHMgSnNvblRyYW5zZm9ybSB7XHJcbiAgICBzdGF0aWMgc2VyaWFsaXplKG9iaiwgb3B0aW9ucywgcmVwbGFjZXIsIHNwYWNlKSB7XHJcbiAgICAgICAgY29uc3QganNvbiA9IHRoaXMudG9KU09OKG9iaiwgb3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGpzb24sIHJlcGxhY2VyLCBzcGFjZSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdG9KU09OKG9iaiwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgbGV0IHJlcztcclxuICAgICAgICBsZXQgdGFyZ2V0U2NoZW1hID0gb3B0aW9ucy50YXJnZXRTY2hlbWE7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hTmFtZSA9IG9wdGlvbnMuc2NoZW1hTmFtZSB8fCBERUZBVUxUX1NDSEVNQTtcclxuICAgICAgICBpZiAoaXNDb252ZXJ0aWJsZShvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmoudG9KU09OKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgcmVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBvYmopIHtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMudG9KU09OKGl0ZW0sIG9wdGlvbnMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXRTY2hlbWEgJiYgIXNjaGVtYVN0b3JhZ2UuaGFzKHRhcmdldFNjaGVtYSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uRXJyb3IoXCJDYW5ub3QgZ2V0IHNjaGVtYSBmb3IgYHRhcmdldFNjaGVtYWAgcGFyYW1cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFyZ2V0U2NoZW1hID0gKHRhcmdldFNjaGVtYSB8fCBvYmouY29uc3RydWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoc2NoZW1hU3RvcmFnZS5oYXModGFyZ2V0U2NoZW1hKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0U2NoZW1hKTtcclxuICAgICAgICAgICAgICAgIHJlcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZWRTY2hlbWEgPSB0aGlzLmdldFNjaGVtYUJ5TmFtZShzY2hlbWEsIHNjaGVtYU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmFtZWRTY2hlbWEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gbmFtZWRTY2hlbWFba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqSXRlbSA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaXRlbS5vcHRpb25hbCAmJiBvYmpJdGVtID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoaXRlbS5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvYmpJdGVtID09PSBpdGVtLmRlZmF1bHRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5vcHRpb25hbCAmJiBvYmpJdGVtID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJpYWxpemVyRXJyb3IodGFyZ2V0U2NoZW1hLm5hbWUsIGBQcm9wZXJ0eSAnJHtrZXl9JyBpcyByZXF1aXJlZC5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0udHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29udmVydGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmpJdGVtLm1hcCgoZWwpID0+IGl0ZW0uY29udmVydGVyLnRvSlNPTihlbCwgb2JqKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0ZW0uY29udmVydGVyLnRvSlNPTihvYmpJdGVtLCBvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqSXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmpJdGVtLm1hcCgoZWwpID0+IHRoaXMudG9KU09OKGVsLCB7IHNjaGVtYU5hbWUgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnRvSlNPTihvYmpJdGVtLCB7IHNjaGVtYU5hbWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1R5cGVzKHZhbHVlLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1ZhbHVlcyh2YWx1ZSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1tpdGVtLm5hbWUgfHwga2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFNlcmlhbGl6ZXJFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJpYWxpemVyRXJyb3Ioc2NoZW1hLnRhcmdldC5uYW1lLCBgUHJvcGVydHkgJyR7a2V5fScgaXMgd3JvbmcuICR7ZS5tZXNzYWdlfWAsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IHRoaXMudG9KU09OKG9ialtrZXldLCB7IHNjaGVtYU5hbWUgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcyA9IG9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBKc29uUGFyc2VyIGV4dGVuZHMgSnNvblRyYW5zZm9ybSB7XHJcbiAgICBzdGF0aWMgcGFyc2UoZGF0YSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUpTT04ob2JqLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tSlNPTih0YXJnZXQsIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRTY2hlbWEgPSBvcHRpb25zLnRhcmdldFNjaGVtYTtcclxuICAgICAgICBjb25zdCBzY2hlbWFOYW1lID0gb3B0aW9ucy5zY2hlbWFOYW1lIHx8IERFRkFVTFRfU0NIRU1BO1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IG5ldyB0YXJnZXRTY2hlbWEoKTtcclxuICAgICAgICBpZiAoaXNDb252ZXJ0aWJsZShvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmouZnJvbUpTT04odGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0U2NoZW1hKTtcclxuICAgICAgICBjb25zdCBuYW1lZFNjaGVtYSA9IHRoaXMuZ2V0U2NoZW1hQnlOYW1lKHNjaGVtYSwgc2NoZW1hTmFtZSk7XHJcbiAgICAgICAgY29uc3Qga2V5RXJyb3JzID0ge307XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RyaWN0UHJvcGVydHkgJiYgIUFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICBKc29uUGFyc2VyLmNoZWNrU3RyaWN0UHJvcGVydHkodGFyZ2V0LCBuYW1lZFNjaGVtYSwgc2NoZW1hKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmFtZWRTY2hlbWEpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBuYW1lZFNjaGVtYVtrZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGl0ZW0ubmFtZSB8fCBrZXk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldFtuYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIChpdGVtLm9wdGlvbmFsIHx8IGl0ZW0uZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0ub3B0aW9uYWwgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihzY2hlbWEsIGBQcm9wZXJ0eSAnJHtuYW1lfScgaXMgcmVxdWlyZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrVHlwZXModmFsdWUsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1ZhbHVlcyh2YWx1ZSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChpdGVtLnR5cGUpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29udmVydGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlLm1hcCgoZWwpID0+IGl0ZW0uY29udmVydGVyLmZyb21KU09OKGVsLCBvYmopKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gaXRlbS5jb252ZXJ0ZXIuZnJvbUpTT04odmFsdWUsIG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U2NoZW1hOiBpdGVtLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5yZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlLm1hcCgoZWwpID0+IHRoaXMuZnJvbUpTT04oZWwsIG5ld09wdGlvbnMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdGhpcy5mcm9tSlNPTih2YWx1ZSwgbmV3T3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgUGFyc2VyRXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IG5ldyBQYXJzZXJFcnJvcihzY2hlbWEsIGBQcm9wZXJ0eSAnJHtrZXl9JyBpcyB3cm9uZy4gJHtlLm1lc3NhZ2V9YCwgZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdHJpY3RBbGxLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5RXJyb3JzW2tleV0gPSBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoa2V5RXJyb3JzKTtcclxuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEtleUVycm9yKHNjaGVtYSwga2V5cywga2V5RXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjaGVja1N0cmljdFByb3BlcnR5KHRhcmdldCwgbmFtZWRTY2hlbWEsIHNjaGVtYSkge1xyXG4gICAgICAgIGNvbnN0IGpzb25Qcm9wcyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hUHJvcHMgPSBPYmplY3Qua2V5cyhuYW1lZFNjaGVtYSk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGpzb25Qcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoc2NoZW1hUHJvcHMuaW5kZXhPZihrZXkpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlFcnJvcihzY2hlbWEsIGtleXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBnZXRWYWxpZGF0aW9ucyhpdGVtKSB7XHJcbiAgICBjb25zdCB2YWxpZGF0aW9ucyA9IFtdO1xyXG4gICAgaWYgKGl0ZW0ucGF0dGVybikge1xyXG4gICAgICAgIHZhbGlkYXRpb25zLnB1c2gobmV3IFBhdHRlcm5WYWxpZGF0aW9uKGl0ZW0ucGF0dGVybikpO1xyXG4gICAgfVxyXG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gZXhwb3J0cy5Kc29uUHJvcFR5cGVzLk51bWJlciB8fCBpdGVtLnR5cGUgPT09IGV4cG9ydHMuSnNvblByb3BUeXBlcy5BbnkpIHtcclxuICAgICAgICBpZiAoaXRlbS5taW5JbmNsdXNpdmUgIT09IHVuZGVmaW5lZCB8fCBpdGVtLm1heEluY2x1c2l2ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25zLnB1c2gobmV3IEluY2x1c2l2ZVZhbGlkYXRpb24oaXRlbS5taW5JbmNsdXNpdmUsIGl0ZW0ubWF4SW5jbHVzaXZlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVtLm1pbkV4Y2x1c2l2ZSAhPT0gdW5kZWZpbmVkIHx8IGl0ZW0ubWF4RXhjbHVzaXZlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGlvbnMucHVzaChuZXcgRXhjbHVzaXZlVmFsaWRhdGlvbihpdGVtLm1pbkV4Y2x1c2l2ZSwgaXRlbS5tYXhFeGNsdXNpdmUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uZW51bWVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9ucy5wdXNoKG5ldyBFbnVtZXJhdGlvblZhbGlkYXRpb24oaXRlbS5lbnVtZXJhdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpdGVtLnR5cGUgPT09IGV4cG9ydHMuSnNvblByb3BUeXBlcy5TdHJpbmcgfHwgaXRlbS5yZXBlYXRlZCB8fCBpdGVtLnR5cGUgPT09IGV4cG9ydHMuSnNvblByb3BUeXBlcy5BbnkpIHtcclxuICAgICAgICBpZiAoaXRlbS5sZW5ndGggIT09IHVuZGVmaW5lZCB8fCBpdGVtLm1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkIHx8IGl0ZW0ubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGlvbnMucHVzaChuZXcgTGVuZ3RoVmFsaWRhdGlvbihpdGVtLmxlbmd0aCwgaXRlbS5taW5MZW5ndGgsIGl0ZW0ubWF4TGVuZ3RoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbGlkYXRpb25zO1xyXG59XHJcbmNvbnN0IEpzb25Qcm9wID0gKG9wdGlvbnMgPSB7fSkgPT4gKHRhcmdldCwgcHJvcGVydHlLZXkpID0+IHtcclxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBDYW5ub3Qgc2V0IHR5cGUgZm9yICR7cHJvcGVydHlLZXl9IHByb3BlcnR5IG9mICR7dGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWV9IHNjaGVtYWA7XHJcbiAgICBsZXQgc2NoZW1hO1xyXG4gICAgaWYgKCFzY2hlbWFTdG9yYWdlLmhhcyh0YXJnZXQuY29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5jcmVhdGUodGFyZ2V0LmNvbnN0cnVjdG9yKTtcclxuICAgICAgICBzY2hlbWFTdG9yYWdlLnNldCh0YXJnZXQuY29uc3RydWN0b3IsIHNjaGVtYSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzY2hlbWEgPSBzY2hlbWFTdG9yYWdlLmdldCh0YXJnZXQuY29uc3RydWN0b3IpO1xyXG4gICAgICAgIGlmIChzY2hlbWEudGFyZ2V0ICE9PSB0YXJnZXQuY29uc3RydWN0b3IpIHtcclxuICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5jcmVhdGUodGFyZ2V0LmNvbnN0cnVjdG9yKTtcclxuICAgICAgICAgICAgc2NoZW1hU3RvcmFnZS5zZXQodGFyZ2V0LmNvbnN0cnVjdG9yLCBzY2hlbWEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGRlZmF1bHRTY2hlbWEgPSB7XHJcbiAgICAgICAgdHlwZTogZXhwb3J0cy5Kc29uUHJvcFR5cGVzLkFueSxcclxuICAgICAgICB2YWxpZGF0aW9uczogW10sXHJcbiAgICB9O1xyXG4gICAgY29uc3QgY29weU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRTY2hlbWEsIG9wdGlvbnMpO1xyXG4gICAgY29weU9wdGlvbnMudmFsaWRhdGlvbnMgPSBnZXRWYWxpZGF0aW9ucyhjb3B5T3B0aW9ucyk7XHJcbiAgICBpZiAodHlwZW9mIGNvcHlPcHRpb25zLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICBpZiAoIXNjaGVtYVN0b3JhZ2UuaGFzKGNvcHlPcHRpb25zLnR5cGUpICYmICFpc0NvbnZlcnRpYmxlKGNvcHlPcHRpb25zLnR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlcnJvck1lc3NhZ2V9LiBBc3NpZ25pbmcgdHlwZSBkb2Vzbid0IGhhdmUgc2NoZW1hLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBzY2hlbWFOYW1lcztcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuc2NoZW1hKSkge1xyXG4gICAgICAgIHNjaGVtYU5hbWVzID0gb3B0aW9ucy5zY2hlbWE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzY2hlbWFOYW1lcyA9IFtvcHRpb25zLnNjaGVtYSB8fCBERUZBVUxUX1NDSEVNQV07XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHNjaGVtYU5hbWUgb2Ygc2NoZW1hTmFtZXMpIHtcclxuICAgICAgICBpZiAoIXNjaGVtYS5uYW1lc1tzY2hlbWFOYW1lXSkge1xyXG4gICAgICAgICAgICBzY2hlbWEubmFtZXNbc2NoZW1hTmFtZV0gPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmFtZWRTY2hlbWEgPSBzY2hlbWEubmFtZXNbc2NoZW1hTmFtZV07XHJcbiAgICAgICAgbmFtZWRTY2hlbWFbcHJvcGVydHlLZXldID0gY29weU9wdGlvbnM7XHJcbiAgICB9XHJcbn07XG5cbmV4cG9ydHMuSnNvbkVycm9yID0gSnNvbkVycm9yO1xuZXhwb3J0cy5Kc29uUGFyc2VyID0gSnNvblBhcnNlcjtcbmV4cG9ydHMuSnNvblByb3AgPSBKc29uUHJvcDtcbmV4cG9ydHMuSnNvblNlcmlhbGl6ZXIgPSBKc29uU2VyaWFsaXplcjtcbmV4cG9ydHMuS2V5RXJyb3IgPSBLZXlFcnJvcjtcbmV4cG9ydHMuUGFyc2VyRXJyb3IgPSBQYXJzZXJFcnJvcjtcbmV4cG9ydHMuU2VyaWFsaXplckVycm9yID0gU2VyaWFsaXplckVycm9yO1xuZXhwb3J0cy5UcmFuc2Zvcm1FcnJvciA9IFRyYW5zZm9ybUVycm9yO1xuZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSBWYWxpZGF0aW9uRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/json-schema/build/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/webcrypto/build/webcrypto.js":
/*!*************************************************************!*\
  !*** ./node_modules/@peculiar/webcrypto/build/webcrypto.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n Copyright (c) Peculiar Ventures, LLC\n*/\n\n\n\nvar core = __webpack_require__(/*! webcrypto-core */ \"(ssr)/./node_modules/webcrypto-core/build/webcrypto-core.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar process = __webpack_require__(/*! process */ \"process\");\nvar tslib = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\nvar jsonSchema = __webpack_require__(/*! @peculiar/json-schema */ \"(ssr)/./node_modules/@peculiar/json-schema/build/index.js\");\nvar pvtsutils = __webpack_require__(/*! pvtsutils */ \"(ssr)/./node_modules/pvtsutils/build/index.js\");\nvar asn1Schema = __webpack_require__(/*! @peculiar/asn1-schema */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/index.js\");\n\nfunction _interopNamespaceDefault(e) {\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\n\nvar core__namespace = /*#__PURE__*/_interopNamespaceDefault(core);\nvar crypto__namespace = /*#__PURE__*/_interopNamespaceDefault(crypto);\nvar process__namespace = /*#__PURE__*/_interopNamespaceDefault(process);\n\nconst JsonBase64UrlConverter = {\r\n    fromJSON: (value) => Buffer.from(pvtsutils.Convert.FromBase64Url(value)),\r\n    toJSON: (value) => pvtsutils.Convert.ToBase64Url(value),\r\n};\n\nclass CryptoKey extends core__namespace.CryptoKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.data = Buffer.alloc(0);\r\n        this.algorithm = { name: \"\" };\r\n        this.extractable = false;\r\n        this.type = \"secret\";\r\n        this.usages = [];\r\n        this.kty = \"oct\";\r\n        this.alg = \"\";\r\n    }\r\n}\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ name: \"ext\", type: jsonSchema.JsonPropTypes.Boolean, optional: true })\r\n], CryptoKey.prototype, \"extractable\", void 0);\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ name: \"key_ops\", type: jsonSchema.JsonPropTypes.String, repeated: true, optional: true })\r\n], CryptoKey.prototype, \"usages\", void 0);\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ type: jsonSchema.JsonPropTypes.String })\r\n], CryptoKey.prototype, \"kty\", void 0);\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ type: jsonSchema.JsonPropTypes.String, optional: true })\r\n], CryptoKey.prototype, \"alg\", void 0);\n\nclass SymmetricKey extends CryptoKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.kty = \"oct\";\r\n        this.type = \"secret\";\r\n    }\r\n}\n\nclass AsymmetricKey extends CryptoKey {\r\n}\n\nclass AesCryptoKey extends SymmetricKey {\r\n    get alg() {\r\n        switch (this.algorithm.name.toUpperCase()) {\r\n            case \"AES-CBC\":\r\n                return `A${this.algorithm.length}CBC`;\r\n            case \"AES-CTR\":\r\n                return `A${this.algorithm.length}CTR`;\r\n            case \"AES-GCM\":\r\n                return `A${this.algorithm.length}GCM`;\r\n            case \"AES-KW\":\r\n                return `A${this.algorithm.length}KW`;\r\n            case \"AES-CMAC\":\r\n                return `A${this.algorithm.length}CMAC`;\r\n            case \"AES-ECB\":\r\n                return `A${this.algorithm.length}ECB`;\r\n            default:\r\n                throw new core__namespace.AlgorithmError(\"Unsupported algorithm name\");\r\n        }\r\n    }\r\n    set alg(value) {\r\n    }\r\n}\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ name: \"k\", converter: JsonBase64UrlConverter })\r\n], AesCryptoKey.prototype, \"data\", void 0);\n\nconst keyStorage = new WeakMap();\r\nfunction getCryptoKey(key) {\r\n    const res = keyStorage.get(key);\r\n    if (!res) {\r\n        throw new core__namespace.OperationError(\"Cannot get CryptoKey from secure storage\");\r\n    }\r\n    return res;\r\n}\r\nfunction setCryptoKey(value) {\r\n    const key = core__namespace.CryptoKey.create(value.algorithm, value.type, value.extractable, value.usages);\r\n    Object.freeze(key);\r\n    keyStorage.set(key, value);\r\n    return key;\r\n}\n\nclass AesCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const key = new AesCryptoKey();\r\n        key.algorithm = algorithm;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        key.data = crypto.randomBytes(algorithm.length >> 3);\r\n        return key;\r\n    }\r\n    static async exportKey(format, key) {\r\n        if (!(key instanceof AesCryptoKey)) {\r\n            throw new Error(\"key: Is not AesCryptoKey\");\r\n        }\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(key);\r\n            case \"raw\":\r\n                return new Uint8Array(key.data).buffer;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        let key;\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                key = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: AesCryptoKey });\r\n                break;\r\n            case \"raw\":\r\n                key = new AesCryptoKey();\r\n                key.data = Buffer.from(keyData);\r\n                break;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n        key.algorithm = algorithm;\r\n        key.algorithm.length = key.data.length << 3;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        switch (key.algorithm.length) {\r\n            case 128:\r\n            case 192:\r\n            case 256:\r\n                break;\r\n            default:\r\n                throw new core__namespace.OperationError(\"keyData: Is wrong key length\");\r\n        }\r\n        return key;\r\n    }\r\n    static async encrypt(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"AES-CBC\":\r\n                return this.encryptAesCBC(algorithm, key, Buffer.from(data));\r\n            case \"AES-CTR\":\r\n                return this.encryptAesCTR(algorithm, key, Buffer.from(data));\r\n            case \"AES-GCM\":\r\n                return this.encryptAesGCM(algorithm, key, Buffer.from(data));\r\n            case \"AES-KW\":\r\n                return this.encryptAesKW(algorithm, key, Buffer.from(data));\r\n            case \"AES-ECB\":\r\n                return this.encryptAesECB(algorithm, key, Buffer.from(data));\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async decrypt(algorithm, key, data) {\r\n        if (!(key instanceof AesCryptoKey)) {\r\n            throw new Error(\"key: Is not AesCryptoKey\");\r\n        }\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"AES-CBC\":\r\n                return this.decryptAesCBC(algorithm, key, Buffer.from(data));\r\n            case \"AES-CTR\":\r\n                return this.decryptAesCTR(algorithm, key, Buffer.from(data));\r\n            case \"AES-GCM\":\r\n                return this.decryptAesGCM(algorithm, key, Buffer.from(data));\r\n            case \"AES-KW\":\r\n                return this.decryptAesKW(algorithm, key, Buffer.from(data));\r\n            case \"AES-ECB\":\r\n                return this.decryptAesECB(algorithm, key, Buffer.from(data));\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async encryptAesCBC(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptAesCBC(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptAesCTR(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ctr`, key.data, Buffer.from(algorithm.counter));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptAesCTR(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ctr`, key.data, new Uint8Array(algorithm.counter));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptAesGCM(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-gcm`, key.data, Buffer.from(algorithm.iv), {\r\n            authTagLength: (algorithm.tagLength || 128) >> 3,\r\n        });\r\n        if (algorithm.additionalData) {\r\n            cipher.setAAD(Buffer.from(algorithm.additionalData));\r\n        }\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final(), cipher.getAuthTag()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptAesGCM(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-gcm`, key.data, new Uint8Array(algorithm.iv));\r\n        const tagLength = (algorithm.tagLength || 128) >> 3;\r\n        const enc = data.slice(0, data.length - tagLength);\r\n        const tag = data.slice(data.length - tagLength);\r\n        if (algorithm.additionalData) {\r\n            decipher.setAAD(Buffer.from(algorithm.additionalData));\r\n        }\r\n        decipher.setAuthTag(tag);\r\n        let dec = decipher.update(enc);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptAesKW(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        return new Uint8Array(enc).buffer;\r\n    }\r\n    static async decryptAesKW(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptAesECB(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptAesECB(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n}\r\nAesCrypto.AES_KW_IV = Buffer.from(\"A6A6A6A6A6A6A6A6\", \"hex\");\n\nclass AesCbcProvider extends core__namespace.AesCbcProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nconst zero = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\r\nconst rb = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135]);\r\nconst blockSize = 16;\r\nfunction bitShiftLeft(buffer) {\r\n    const shifted = Buffer.alloc(buffer.length);\r\n    const last = buffer.length - 1;\r\n    for (let index = 0; index < last; index++) {\r\n        shifted[index] = buffer[index] << 1;\r\n        if (buffer[index + 1] & 0x80) {\r\n            shifted[index] += 0x01;\r\n        }\r\n    }\r\n    shifted[last] = buffer[last] << 1;\r\n    return shifted;\r\n}\r\nfunction xor(a, b) {\r\n    const length = Math.min(a.length, b.length);\r\n    const output = Buffer.alloc(length);\r\n    for (let index = 0; index < length; index++) {\r\n        output[index] = a[index] ^ b[index];\r\n    }\r\n    return output;\r\n}\r\nfunction aes(key, message) {\r\n    const cipher = crypto__namespace.createCipheriv(`aes${key.length << 3}`, key, zero);\r\n    const result = cipher.update(message);\r\n    cipher.final();\r\n    return result;\r\n}\r\nfunction getMessageBlock(message, blockIndex) {\r\n    const block = Buffer.alloc(blockSize);\r\n    const start = blockIndex * blockSize;\r\n    const end = start + blockSize;\r\n    message.copy(block, 0, start, end);\r\n    return block;\r\n}\r\nfunction getPaddedMessageBlock(message, blockIndex) {\r\n    const block = Buffer.alloc(blockSize);\r\n    const start = blockIndex * blockSize;\r\n    const end = message.length;\r\n    block.fill(0);\r\n    message.copy(block, 0, start, end);\r\n    block[end - start] = 0x80;\r\n    return block;\r\n}\r\nfunction generateSubkeys(key) {\r\n    const l = aes(key, zero);\r\n    let subkey1 = bitShiftLeft(l);\r\n    if (l[0] & 0x80) {\r\n        subkey1 = xor(subkey1, rb);\r\n    }\r\n    let subkey2 = bitShiftLeft(subkey1);\r\n    if (subkey1[0] & 0x80) {\r\n        subkey2 = xor(subkey2, rb);\r\n    }\r\n    return { subkey1, subkey2 };\r\n}\r\nfunction aesCmac(key, message) {\r\n    const subkeys = generateSubkeys(key);\r\n    let blockCount = Math.ceil(message.length / blockSize);\r\n    let lastBlockCompleteFlag;\r\n    let lastBlock;\r\n    if (blockCount === 0) {\r\n        blockCount = 1;\r\n        lastBlockCompleteFlag = false;\r\n    }\r\n    else {\r\n        lastBlockCompleteFlag = (message.length % blockSize === 0);\r\n    }\r\n    const lastBlockIndex = blockCount - 1;\r\n    if (lastBlockCompleteFlag) {\r\n        lastBlock = xor(getMessageBlock(message, lastBlockIndex), subkeys.subkey1);\r\n    }\r\n    else {\r\n        lastBlock = xor(getPaddedMessageBlock(message, lastBlockIndex), subkeys.subkey2);\r\n    }\r\n    let x = zero;\r\n    let y;\r\n    for (let index = 0; index < lastBlockIndex; index++) {\r\n        y = xor(x, getMessageBlock(message, index));\r\n        x = aes(key, y);\r\n    }\r\n    y = xor(lastBlock, x);\r\n    return aes(key, y);\r\n}\r\nclass AesCmacProvider extends core__namespace.AesCmacProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        const result = aesCmac(getCryptoKey(key).data, Buffer.from(data));\r\n        return new Uint8Array(result).buffer;\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        const signature2 = await this.sign(algorithm, key, data);\r\n        return Buffer.from(signature).compare(Buffer.from(signature2)) === 0;\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass AesCtrProvider extends core__namespace.AesCtrProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass AesGcmProvider extends core__namespace.AesGcmProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass AesKwProvider extends core__namespace.AesKwProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass AesEcbProvider extends core__namespace.AesEcbProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass DesCryptoKey extends SymmetricKey {\r\n    get alg() {\r\n        switch (this.algorithm.name.toUpperCase()) {\r\n            case \"DES-CBC\":\r\n                return `DES-CBC`;\r\n            case \"DES-EDE3-CBC\":\r\n                return `3DES-CBC`;\r\n            default:\r\n                throw new core__namespace.AlgorithmError(\"Unsupported algorithm name\");\r\n        }\r\n    }\r\n    set alg(value) {\r\n    }\r\n}\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ name: \"k\", converter: JsonBase64UrlConverter })\r\n], DesCryptoKey.prototype, \"data\", void 0);\n\nclass DesCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const key = new DesCryptoKey();\r\n        key.algorithm = algorithm;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        key.data = crypto.randomBytes(algorithm.length >> 3);\r\n        return key;\r\n    }\r\n    static async exportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(key);\r\n            case \"raw\":\r\n                return new Uint8Array(key.data).buffer;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        let key;\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                key = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: DesCryptoKey });\r\n                break;\r\n            case \"raw\":\r\n                key = new DesCryptoKey();\r\n                key.data = Buffer.from(keyData);\r\n                break;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n        key.algorithm = algorithm;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static async encrypt(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"DES-CBC\":\r\n                return this.encryptDesCBC(algorithm, key, Buffer.from(data));\r\n            case \"DES-EDE3-CBC\":\r\n                return this.encryptDesEDE3CBC(algorithm, key, Buffer.from(data));\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async decrypt(algorithm, key, data) {\r\n        if (!(key instanceof DesCryptoKey)) {\r\n            throw new Error(\"key: Is not DesCryptoKey\");\r\n        }\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"DES-CBC\":\r\n                return this.decryptDesCBC(algorithm, key, Buffer.from(data));\r\n            case \"DES-EDE3-CBC\":\r\n                return this.decryptDesEDE3CBC(algorithm, key, Buffer.from(data));\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async encryptDesCBC(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptDesCBC(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptDesEDE3CBC(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`des-ede3-cbc`, key.data, Buffer.from(algorithm.iv));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptDesEDE3CBC(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`des-ede3-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n}\n\nclass DesCbcProvider extends core__namespace.DesProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.keySizeBits = 64;\r\n        this.ivSize = 8;\r\n        this.name = \"DES-CBC\";\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await DesCrypto.generateKey({\r\n            name: this.name,\r\n            length: this.keySizeBits,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return DesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);\r\n        if (key.data.length !== (this.keySizeBits >> 3)) {\r\n            throw new core__namespace.OperationError(\"keyData: Wrong key size\");\r\n        }\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass DesEde3CbcProvider extends core__namespace.DesProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.keySizeBits = 192;\r\n        this.ivSize = 8;\r\n        this.name = \"DES-EDE3-CBC\";\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await DesCrypto.generateKey({\r\n            name: this.name,\r\n            length: this.keySizeBits,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return DesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);\r\n        if (key.data.length !== (this.keySizeBits >> 3)) {\r\n            throw new core__namespace.OperationError(\"keyData: Wrong key size\");\r\n        }\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nfunction getJwkAlgorithm(algorithm) {\r\n    switch (algorithm.name.toUpperCase()) {\r\n        case \"RSA-OAEP\": {\r\n            const mdSize = /(\\d+)$/.exec(algorithm.hash.name)[1];\r\n            return `RSA-OAEP${mdSize !== \"1\" ? `-${mdSize}` : \"\"}`;\r\n        }\r\n        case \"RSASSA-PKCS1-V1_5\":\r\n            return `RS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\r\n        case \"RSA-PSS\":\r\n            return `PS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\r\n        case \"RSA-PKCS1\":\r\n            return `RS1`;\r\n        default:\r\n            throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n    }\r\n}\n\nclass RsaPrivateKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"private\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\r\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"RSA\",\r\n            alg: getJwkAlgorithm(this.algorithm),\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.RsaPrivateKey });\r\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\r\n        keyInfo.privateKeyAlgorithm.parameters = null;\r\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n    }\r\n}\n\nclass RsaPublicKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"public\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\r\n        return asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"RSA\",\r\n            alg: getJwkAlgorithm(this.algorithm),\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.RsaPublicKey });\r\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\r\n        keyInfo.publicKeyAlgorithm.parameters = null;\r\n        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(key);\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n    }\r\n}\n\nclass RsaCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const privateKey = new RsaPrivateKey();\r\n        privateKey.algorithm = algorithm;\r\n        privateKey.extractable = extractable;\r\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\r\n        const publicKey = new RsaPublicKey();\r\n        publicKey.algorithm = algorithm;\r\n        publicKey.extractable = true;\r\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\r\n        const publicExponent = Buffer.concat([\r\n            Buffer.alloc(4 - algorithm.publicExponent.byteLength, 0),\r\n            Buffer.from(algorithm.publicExponent),\r\n        ]).readInt32BE(0);\r\n        const keys = crypto.generateKeyPairSync(\"rsa\", {\r\n            modulusLength: algorithm.modulusLength,\r\n            publicExponent,\r\n            publicKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"spki\",\r\n            },\r\n            privateKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"pkcs8\",\r\n            },\r\n        });\r\n        privateKey.data = keys.privateKey;\r\n        publicKey.data = keys.publicKey;\r\n        const res = {\r\n            privateKey,\r\n            publicKey,\r\n        };\r\n        return res;\r\n    }\r\n    static async exportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(key);\r\n            case \"pkcs8\":\r\n            case \"spki\":\r\n                return new Uint8Array(key.data).buffer;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\": {\r\n                const jwk = keyData;\r\n                if (jwk.d) {\r\n                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.RsaPrivateKey });\r\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n                else {\r\n                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.RsaPublicKey });\r\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n            }\r\n            case \"spki\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\r\n                const asnKey = asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);\r\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"pkcs8\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\r\n                const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);\r\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static async sign(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"RSA-PSS\":\r\n            case \"RSASSA-PKCS1-V1_5\":\r\n                return this.signRsa(algorithm, key, data);\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async verify(algorithm, key, signature, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"RSA-PSS\":\r\n            case \"RSASSA-PKCS1-V1_5\":\r\n                return this.verifySSA(algorithm, key, data, signature);\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async encrypt(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"RSA-OAEP\":\r\n                return this.encryptOAEP(algorithm, key, data);\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async decrypt(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"RSA-OAEP\":\r\n                return this.decryptOAEP(algorithm, key, data);\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\r\n        keyInfo.privateKeyAlgorithm.parameters = null;\r\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);\r\n        const key = new RsaPrivateKey();\r\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\r\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static importPublicKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\r\n        keyInfo.publicKeyAlgorithm.parameters = null;\r\n        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(asnKey);\r\n        const key = new RsaPublicKey();\r\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\r\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static getCryptoAlgorithm(alg) {\r\n        switch (alg.hash.name.toUpperCase()) {\r\n            case \"SHA-1\":\r\n                return \"RSA-SHA1\";\r\n            case \"SHA-256\":\r\n                return \"RSA-SHA256\";\r\n            case \"SHA-384\":\r\n                return \"RSA-SHA384\";\r\n            case \"SHA-512\":\r\n                return \"RSA-SHA512\";\r\n            case \"SHA3-256\":\r\n                return \"RSA-SHA3-256\";\r\n            case \"SHA3-384\":\r\n                return \"RSA-SHA3-384\";\r\n            case \"SHA3-512\":\r\n                return \"RSA-SHA3-512\";\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm.hash: Is not recognized\");\r\n        }\r\n    }\r\n    static signRsa(algorithm, key, data) {\r\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\r\n        const signer = crypto.createSign(cryptoAlg);\r\n        signer.update(Buffer.from(data));\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\r\n            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;\r\n            options.saltLength = algorithm.saltLength;\r\n        }\r\n        const signature = signer.sign(options);\r\n        return new Uint8Array(signature).buffer;\r\n    }\r\n    static verifySSA(algorithm, key, data, signature) {\r\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\r\n        const signer = crypto.createVerify(cryptoAlg);\r\n        signer.update(Buffer.from(data));\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\r\n            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;\r\n            options.saltLength = algorithm.saltLength;\r\n        }\r\n        const ok = signer.verify(options, signature);\r\n        return ok;\r\n    }\r\n    static encryptOAEP(algorithm, key, data) {\r\n        const options = {\r\n            key: `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`,\r\n            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\r\n        };\r\n        if (algorithm.label) ;\r\n        return new Uint8Array(crypto.publicEncrypt(options, data)).buffer;\r\n    }\r\n    static decryptOAEP(algorithm, key, data) {\r\n        const options = {\r\n            key: `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`,\r\n            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\r\n        };\r\n        if (algorithm.label) ;\r\n        return new Uint8Array(crypto.privateDecrypt(options, data)).buffer;\r\n    }\r\n}\r\nRsaCrypto.publicKeyUsages = [\"verify\", \"encrypt\", \"wrapKey\"];\r\nRsaCrypto.privateKeyUsages = [\"sign\", \"decrypt\", \"unwrapKey\"];\n\nclass RsaSsaProvider extends core__namespace.RsaSsaProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.hashAlgorithms = [\r\n            \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\r\n            \"shake128\", \"shake256\",\r\n            \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"\r\n        ];\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await RsaCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\r\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass RsaPssProvider extends core__namespace.RsaPssProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.hashAlgorithms = [\r\n            \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\r\n            \"shake128\", \"shake256\",\r\n            \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"\r\n        ];\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await RsaCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\r\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass ShaCrypto {\r\n    static size(algorithm) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"SHA-1\":\r\n                return 160;\r\n            case \"SHA-256\":\r\n            case \"SHA3-256\":\r\n                return 256;\r\n            case \"SHA-384\":\r\n            case \"SHA3-384\":\r\n                return 384;\r\n            case \"SHA-512\":\r\n            case \"SHA3-512\":\r\n                return 512;\r\n            default:\r\n                throw new Error(\"Unrecognized name\");\r\n        }\r\n    }\r\n    static getAlgorithmName(algorithm) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"SHA-1\":\r\n                return \"sha1\";\r\n            case \"SHA-256\":\r\n                return \"sha256\";\r\n            case \"SHA-384\":\r\n                return \"sha384\";\r\n            case \"SHA-512\":\r\n                return \"sha512\";\r\n            case \"SHA3-256\":\r\n                return \"sha3-256\";\r\n            case \"SHA3-384\":\r\n                return \"sha3-384\";\r\n            case \"SHA3-512\":\r\n                return \"sha3-512\";\r\n            default:\r\n                throw new Error(\"Unrecognized name\");\r\n        }\r\n    }\r\n    static digest(algorithm, data) {\r\n        const hashAlg = this.getAlgorithmName(algorithm);\r\n        const hash = crypto.createHash(hashAlg)\r\n            .update(Buffer.from(data)).digest();\r\n        return new Uint8Array(hash).buffer;\r\n    }\r\n}\n\nclass RsaOaepProvider extends core__namespace.RsaOaepProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await RsaCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        const internalKey = getCryptoKey(key);\r\n        const dataView = new Uint8Array(data);\r\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\r\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\r\n        const dataLength = dataView.byteLength;\r\n        const psLength = keySize - dataLength - 2 * hashSize - 2;\r\n        if (dataLength > keySize - 2 * hashSize - 2) {\r\n            throw new Error(\"Data too large\");\r\n        }\r\n        const message = new Uint8Array(keySize);\r\n        const seed = message.subarray(1, hashSize + 1);\r\n        const dataBlock = message.subarray(hashSize + 1);\r\n        dataBlock.set(dataView, hashSize + psLength + 1);\r\n        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\"))\r\n            .update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0)))\r\n            .digest();\r\n        dataBlock.set(labelHash, 0);\r\n        dataBlock[hashSize + psLength] = 1;\r\n        crypto.randomFillSync(seed);\r\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\r\n        for (let i = 0; i < dataBlock.length; i++) {\r\n            dataBlock[i] ^= dataBlockMask[i];\r\n        }\r\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\r\n        for (let i = 0; i < seed.length; i++) {\r\n            seed[i] ^= seedMask[i];\r\n        }\r\n        if (!internalKey.pem) {\r\n            internalKey.pem = `-----BEGIN PUBLIC KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\r\n        }\r\n        const pkcs0 = crypto.publicEncrypt({\r\n            key: internalKey.pem,\r\n            padding: crypto.constants.RSA_NO_PADDING,\r\n        }, Buffer.from(message));\r\n        return new Uint8Array(pkcs0).buffer;\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        const internalKey = getCryptoKey(key);\r\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\r\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\r\n        const dataLength = data.byteLength;\r\n        if (dataLength !== keySize) {\r\n            throw new Error(\"Bad data\");\r\n        }\r\n        if (!internalKey.pem) {\r\n            internalKey.pem = `-----BEGIN PRIVATE KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\r\n        }\r\n        let pkcs0 = crypto.privateDecrypt({\r\n            key: internalKey.pem,\r\n            padding: crypto.constants.RSA_NO_PADDING,\r\n        }, Buffer.from(data));\r\n        const z = pkcs0[0];\r\n        const seed = pkcs0.subarray(1, hashSize + 1);\r\n        const dataBlock = pkcs0.subarray(hashSize + 1);\r\n        if (z !== 0) {\r\n            throw new Error(\"Decryption failed\");\r\n        }\r\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\r\n        for (let i = 0; i < seed.length; i++) {\r\n            seed[i] ^= seedMask[i];\r\n        }\r\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\r\n        for (let i = 0; i < dataBlock.length; i++) {\r\n            dataBlock[i] ^= dataBlockMask[i];\r\n        }\r\n        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\"))\r\n            .update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0)))\r\n            .digest();\r\n        for (let i = 0; i < hashSize; i++) {\r\n            if (labelHash[i] !== dataBlock[i]) {\r\n                throw new Error(\"Decryption failed\");\r\n            }\r\n        }\r\n        let psEnd = hashSize;\r\n        for (; psEnd < dataBlock.length; psEnd++) {\r\n            const psz = dataBlock[psEnd];\r\n            if (psz === 1) {\r\n                break;\r\n            }\r\n            if (psz !== 0) {\r\n                throw new Error(\"Decryption failed\");\r\n            }\r\n        }\r\n        if (psEnd === dataBlock.length) {\r\n            throw new Error(\"Decryption failed\");\r\n        }\r\n        pkcs0 = dataBlock.subarray(psEnd + 1);\r\n        return new Uint8Array(pkcs0).buffer;\r\n    }\r\n    async onExportKey(format, key) {\r\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\r\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\r\n        }\r\n    }\r\n    mgf1(algorithm, seed, length = 0) {\r\n        const hashSize = ShaCrypto.size(algorithm) >> 3;\r\n        const mask = new Uint8Array(length);\r\n        const counter = new Uint8Array(4);\r\n        const chunks = Math.ceil(length / hashSize);\r\n        for (let i = 0; i < chunks; i++) {\r\n            counter[0] = i >>> 24;\r\n            counter[1] = (i >>> 16) & 255;\r\n            counter[2] = (i >>> 8) & 255;\r\n            counter[3] = i & 255;\r\n            const submask = mask.subarray(i * hashSize);\r\n            let chunk = crypto.createHash(algorithm.name.replace(\"-\", \"\"))\r\n                .update(seed)\r\n                .update(counter)\r\n                .digest();\r\n            if (chunk.length > submask.length) {\r\n                chunk = chunk.subarray(0, submask.length);\r\n            }\r\n            submask.set(chunk);\r\n        }\r\n        return mask;\r\n    }\r\n}\n\nclass RsaEsProvider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"RSAES-PKCS1-v1_5\";\r\n        this.usages = {\r\n            publicKey: [\"encrypt\", \"wrapKey\"],\r\n            privateKey: [\"decrypt\", \"unwrapKey\"],\r\n        };\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await RsaCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    checkGenerateKeyParams(algorithm) {\r\n        this.checkRequiredProperty(algorithm, \"publicExponent\");\r\n        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {\r\n            throw new TypeError(\"publicExponent: Missing or not a Uint8Array\");\r\n        }\r\n        const publicExponent = pvtsutils.Convert.ToBase64(algorithm.publicExponent);\r\n        if (!(publicExponent === \"Aw==\" || publicExponent === \"AQAB\")) {\r\n            throw new TypeError(\"publicExponent: Must be [3] or [1,0,1]\");\r\n        }\r\n        this.checkRequiredProperty(algorithm, \"modulusLength\");\r\n        switch (algorithm.modulusLength) {\r\n            case 1024:\r\n            case 2048:\r\n            case 4096:\r\n                break;\r\n            default:\r\n                throw new TypeError(\"modulusLength: Must be 1024, 2048, or 4096\");\r\n        }\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        const options = this.toCryptoOptions(key);\r\n        const enc = crypto__namespace.publicEncrypt(options, new Uint8Array(data));\r\n        return new Uint8Array(enc).buffer;\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        const options = this.toCryptoOptions(key);\r\n        const dec = crypto__namespace.privateDecrypt(options, new Uint8Array(data));\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    async onExportKey(format, key) {\r\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\r\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\r\n        }\r\n    }\r\n    toCryptoOptions(key) {\r\n        const type = key.type.toUpperCase();\r\n        return {\r\n            key: `-----BEGIN ${type} KEY-----\\n${getCryptoKey(key).data.toString(\"base64\")}\\n-----END ${type} KEY-----`,\r\n            padding: crypto__namespace.constants.RSA_PKCS1_PADDING,\r\n        };\r\n    }\r\n}\n\nconst namedOIDs = {\r\n    \"1.2.840.10045.3.1.7\": \"P-256\",\r\n    \"P-256\": \"1.2.840.10045.3.1.7\",\r\n    \"1.3.132.0.34\": \"P-384\",\r\n    \"P-384\": \"1.3.132.0.34\",\r\n    \"1.3.132.0.35\": \"P-521\",\r\n    \"P-521\": \"1.3.132.0.35\",\r\n    \"1.3.132.0.10\": \"K-256\",\r\n    \"K-256\": \"1.3.132.0.10\",\r\n    \"brainpoolP160r1\": \"1.3.36.3.3.2.8.1.1.1\",\r\n    \"1.3.36.3.3.2.8.1.1.1\": \"brainpoolP160r1\",\r\n    \"brainpoolP160t1\": \"1.3.36.3.3.2.8.1.1.2\",\r\n    \"1.3.36.3.3.2.8.1.1.2\": \"brainpoolP160t1\",\r\n    \"brainpoolP192r1\": \"1.3.36.3.3.2.8.1.1.3\",\r\n    \"1.3.36.3.3.2.8.1.1.3\": \"brainpoolP192r1\",\r\n    \"brainpoolP192t1\": \"1.3.36.3.3.2.8.1.1.4\",\r\n    \"1.3.36.3.3.2.8.1.1.4\": \"brainpoolP192t1\",\r\n    \"brainpoolP224r1\": \"1.3.36.3.3.2.8.1.1.5\",\r\n    \"1.3.36.3.3.2.8.1.1.5\": \"brainpoolP224r1\",\r\n    \"brainpoolP224t1\": \"1.3.36.3.3.2.8.1.1.6\",\r\n    \"1.3.36.3.3.2.8.1.1.6\": \"brainpoolP224t1\",\r\n    \"brainpoolP256r1\": \"1.3.36.3.3.2.8.1.1.7\",\r\n    \"1.3.36.3.3.2.8.1.1.7\": \"brainpoolP256r1\",\r\n    \"brainpoolP256t1\": \"1.3.36.3.3.2.8.1.1.8\",\r\n    \"1.3.36.3.3.2.8.1.1.8\": \"brainpoolP256t1\",\r\n    \"brainpoolP320r1\": \"1.3.36.3.3.2.8.1.1.9\",\r\n    \"1.3.36.3.3.2.8.1.1.9\": \"brainpoolP320r1\",\r\n    \"brainpoolP320t1\": \"1.3.36.3.3.2.8.1.1.10\",\r\n    \"1.3.36.3.3.2.8.1.1.10\": \"brainpoolP320t1\",\r\n    \"brainpoolP384r1\": \"1.3.36.3.3.2.8.1.1.11\",\r\n    \"1.3.36.3.3.2.8.1.1.11\": \"brainpoolP384r1\",\r\n    \"brainpoolP384t1\": \"1.3.36.3.3.2.8.1.1.12\",\r\n    \"1.3.36.3.3.2.8.1.1.12\": \"brainpoolP384t1\",\r\n    \"brainpoolP512r1\": \"1.3.36.3.3.2.8.1.1.13\",\r\n    \"1.3.36.3.3.2.8.1.1.13\": \"brainpoolP512r1\",\r\n    \"brainpoolP512t1\": \"1.3.36.3.3.2.8.1.1.14\",\r\n    \"1.3.36.3.3.2.8.1.1.14\": \"brainpoolP512t1\",\r\n};\r\nfunction getOidByNamedCurve$1(namedCurve) {\r\n    const oid = namedOIDs[namedCurve];\r\n    if (!oid) {\r\n        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\r\n    }\r\n    return oid;\r\n}\n\nclass EcPrivateKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"private\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\r\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"EC\",\r\n            crv: this.algorithm.namedCurve,\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        if (!json.crv) {\r\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\r\n        }\r\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\r\n        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));\r\n        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.EcPrivateKey });\r\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        return this;\r\n    }\r\n}\n\nclass EcPublicKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"public\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\r\n        return new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"EC\",\r\n            crv: this.algorithm.namedCurve,\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        if (!json.crv) {\r\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\r\n        }\r\n        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.EcPublicKey });\r\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\r\n        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));\r\n        keyInfo.publicKey = asn1Schema.AsnSerializer.toASN(key).valueHex;\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        return this;\r\n    }\r\n}\n\nclass Sha1Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA-1\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha256Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA-256\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha384Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA-384\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha512Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA-512\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha3256Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA3-256\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha3384Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA3-384\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha3512Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA3-512\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass EcCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const privateKey = new EcPrivateKey();\r\n        privateKey.algorithm = algorithm;\r\n        privateKey.extractable = extractable;\r\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\r\n        const publicKey = new EcPublicKey();\r\n        publicKey.algorithm = algorithm;\r\n        publicKey.extractable = true;\r\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\r\n        const keys = crypto.generateKeyPairSync(\"ec\", {\r\n            namedCurve: this.getOpenSSLNamedCurve(algorithm.namedCurve),\r\n            publicKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"spki\",\r\n            },\r\n            privateKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"pkcs8\",\r\n            },\r\n        });\r\n        privateKey.data = keys.privateKey;\r\n        publicKey.data = keys.publicKey;\r\n        const res = {\r\n            privateKey,\r\n            publicKey,\r\n        };\r\n        return res;\r\n    }\r\n    static async sign(algorithm, key, data) {\r\n        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);\r\n        const signer = crypto.createSign(cryptoAlg);\r\n        signer.update(Buffer.from(data));\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        const signature = signer.sign(options);\r\n        const ecSignature = asn1Schema.AsnParser.parse(signature, core__namespace.asn1.EcDsaSignature);\r\n        const signatureRaw = core__namespace.EcUtils.encodeSignature(ecSignature, core__namespace.EcCurves.get(key.algorithm.namedCurve).size);\r\n        return signatureRaw.buffer;\r\n    }\r\n    static async verify(algorithm, key, signature, data) {\r\n        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);\r\n        const signer = crypto.createVerify(cryptoAlg);\r\n        signer.update(Buffer.from(data));\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        const ecSignature = new core__namespace.asn1.EcDsaSignature();\r\n        const namedCurve = core__namespace.EcCurves.get(key.algorithm.namedCurve);\r\n        const signaturePoint = core__namespace.EcUtils.decodeSignature(signature, namedCurve.size);\r\n        ecSignature.r = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.r);\r\n        ecSignature.s = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.s);\r\n        const ecSignatureRaw = Buffer.from(asn1Schema.AsnSerializer.serialize(ecSignature));\r\n        const ok = signer.verify(options, ecSignatureRaw);\r\n        return ok;\r\n    }\r\n    static async deriveBits(algorithm, baseKey, length) {\r\n        const cryptoAlg = this.getOpenSSLNamedCurve(baseKey.algorithm.namedCurve);\r\n        const ecdh = crypto.createECDH(cryptoAlg);\r\n        const asnPrivateKey = asn1Schema.AsnParser.parse(baseKey.data, core__namespace.asn1.PrivateKeyInfo);\r\n        const asnEcPrivateKey = asn1Schema.AsnParser.parse(asnPrivateKey.privateKey, core__namespace.asn1.EcPrivateKey);\r\n        ecdh.setPrivateKey(Buffer.from(asnEcPrivateKey.privateKey));\r\n        const asnPublicKey = asn1Schema.AsnParser.parse(algorithm.public.data, core__namespace.asn1.PublicKeyInfo);\r\n        const bits = ecdh.computeSecret(Buffer.from(asnPublicKey.publicKey));\r\n        if (length === null) {\r\n            return bits;\r\n        }\r\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\r\n    }\r\n    static async exportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(key);\r\n            case \"pkcs8\":\r\n            case \"spki\":\r\n                return new Uint8Array(key.data).buffer;\r\n            case \"raw\": {\r\n                const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);\r\n                return publicKeyInfo.publicKey;\r\n            }\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\": {\r\n                const jwk = keyData;\r\n                if (jwk.d) {\r\n                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.EcPrivateKey });\r\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n                else {\r\n                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.EcPublicKey });\r\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n            }\r\n            case \"raw\": {\r\n                const asnKey = new core__namespace.asn1.EcPublicKey(keyData);\r\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"spki\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\r\n                const asnKey = new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);\r\n                this.assertKeyParameters(keyInfo.publicKeyAlgorithm.parameters, algorithm.namedCurve);\r\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"pkcs8\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\r\n                const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);\r\n                this.assertKeyParameters(keyInfo.privateKeyAlgorithm.parameters, algorithm.namedCurve);\r\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static assertKeyParameters(parameters, namedCurve) {\r\n        if (!parameters) {\r\n            throw new core__namespace.CryptoError(\"Key info doesn't have required parameters\");\r\n        }\r\n        let namedCurveIdentifier = \"\";\r\n        try {\r\n            namedCurveIdentifier = asn1Schema.AsnParser.parse(parameters, core__namespace.asn1.ObjectIdentifier).value;\r\n        }\r\n        catch (e) {\r\n            throw new core__namespace.CryptoError(\"Cannot read key info parameters\");\r\n        }\r\n        if (getOidByNamedCurve$1(namedCurve) !== namedCurveIdentifier) {\r\n            throw new core__namespace.CryptoError(\"Key info parameter doesn't match to named curve\");\r\n        }\r\n    }\r\n    static async importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\r\n        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(algorithm.namedCurve)));\r\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);\r\n        const key = new EcPrivateKey();\r\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\r\n        const namedCurve = getOidByNamedCurve$1(algorithm.namedCurve);\r\n        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(namedCurve));\r\n        keyInfo.publicKey = asnKey.value;\r\n        const key = new EcPublicKey();\r\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static getOpenSSLNamedCurve(curve) {\r\n        switch (curve.toUpperCase()) {\r\n            case \"P-256\":\r\n                return \"prime256v1\";\r\n            case \"K-256\":\r\n                return \"secp256k1\";\r\n            case \"P-384\":\r\n                return \"secp384r1\";\r\n            case \"P-521\":\r\n                return \"secp521r1\";\r\n            default:\r\n                return curve;\r\n        }\r\n    }\r\n}\r\nEcCrypto.publicKeyUsages = [\"verify\"];\r\nEcCrypto.privateKeyUsages = [\"sign\", \"deriveKey\", \"deriveBits\"];\n\nclass EcdsaProvider extends core__namespace.EcdsaProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.namedCurves = core__namespace.EcCurves.names;\r\n        this.hashAlgorithms = [\r\n            \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\r\n            \"shake128\", \"shake256\",\r\n            \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"\r\n        ];\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await EcCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        return EcCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        return EcCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return EcCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\r\n            throw new TypeError(\"key: Is not EC CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass EcdhProvider extends core__namespace.EcdhProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.namedCurves = core__namespace.EcCurves.names;\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await EcCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onExportKey(format, key) {\r\n        return EcCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\r\n            throw new TypeError(\"key: Is not EC CryptoKey\");\r\n        }\r\n    }\r\n    async onDeriveBits(algorithm, baseKey, length) {\r\n        const bits = await EcCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);\r\n        return bits;\r\n    }\r\n}\n\nconst edOIDs = {\r\n    [core__namespace.asn1.idEd448]: \"Ed448\",\r\n    \"ed448\": core__namespace.asn1.idEd448,\r\n    [core__namespace.asn1.idX448]: \"X448\",\r\n    \"x448\": core__namespace.asn1.idX448,\r\n    [core__namespace.asn1.idEd25519]: \"Ed25519\",\r\n    \"ed25519\": core__namespace.asn1.idEd25519,\r\n    [core__namespace.asn1.idX25519]: \"X25519\",\r\n    \"x25519\": core__namespace.asn1.idX25519,\r\n};\r\nfunction getOidByNamedCurve(namedCurve) {\r\n    const oid = edOIDs[namedCurve.toLowerCase()];\r\n    if (!oid) {\r\n        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\r\n    }\r\n    return oid;\r\n}\n\nclass EdPrivateKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"private\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\r\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"OKP\",\r\n            crv: this.algorithm.namedCurve,\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        if (!json.crv) {\r\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\r\n        }\r\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);\r\n        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.CurvePrivateKey });\r\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        return this;\r\n    }\r\n}\n\nclass EdPublicKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"public\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\r\n        return keyInfo.publicKey;\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"OKP\",\r\n            crv: this.algorithm.namedCurve,\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, {\r\n            x: pvtsutils.Convert.ToBase64Url(key)\r\n        });\r\n    }\r\n    fromJSON(json) {\r\n        if (!json.crv) {\r\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\r\n        }\r\n        if (!json.x) {\r\n            throw new core__namespace.OperationError(`Cannot get property from JWK. Property 'x' is required`);\r\n        }\r\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);\r\n        keyInfo.publicKey = pvtsutils.Convert.FromBase64Url(json.x);\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        return this;\r\n    }\r\n}\n\nclass EdCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const privateKey = new EdPrivateKey();\r\n        privateKey.algorithm = algorithm;\r\n        privateKey.extractable = extractable;\r\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\r\n        const publicKey = new EdPublicKey();\r\n        publicKey.algorithm = algorithm;\r\n        publicKey.extractable = true;\r\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\r\n        const type = algorithm.namedCurve.toLowerCase();\r\n        const keys = crypto.generateKeyPairSync(type, {\r\n            publicKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"spki\",\r\n            },\r\n            privateKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"pkcs8\",\r\n            },\r\n        });\r\n        privateKey.data = keys.privateKey;\r\n        publicKey.data = keys.publicKey;\r\n        const res = {\r\n            privateKey,\r\n            publicKey,\r\n        };\r\n        return res;\r\n    }\r\n    static async sign(algorithm, key, data) {\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        const signature = crypto.sign(null, Buffer.from(data), options);\r\n        return core__namespace.BufferSourceConverter.toArrayBuffer(signature);\r\n    }\r\n    static async verify(algorithm, key, signature, data) {\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        const ok = crypto.verify(null, Buffer.from(data), options, Buffer.from(signature));\r\n        return ok;\r\n    }\r\n    static async deriveBits(algorithm, baseKey, length) {\r\n        const publicKey = crypto.createPublicKey({\r\n            key: algorithm.public.data,\r\n            format: \"der\",\r\n            type: \"spki\",\r\n        });\r\n        const privateKey = crypto.createPrivateKey({\r\n            key: baseKey.data,\r\n            format: \"der\",\r\n            type: \"pkcs8\",\r\n        });\r\n        const bits = crypto.diffieHellman({\r\n            publicKey,\r\n            privateKey,\r\n        });\r\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\r\n    }\r\n    static async exportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(key);\r\n            case \"pkcs8\":\r\n            case \"spki\":\r\n                return new Uint8Array(key.data).buffer;\r\n            case \"raw\": {\r\n                const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);\r\n                return publicKeyInfo.publicKey;\r\n            }\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\": {\r\n                const jwk = keyData;\r\n                if (jwk.d) {\r\n                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.CurvePrivateKey });\r\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n                else {\r\n                    if (!jwk.x) {\r\n                        throw new TypeError(\"keyData: Cannot get required 'x' filed\");\r\n                    }\r\n                    return this.importPublicKey(pvtsutils.Convert.FromBase64Url(jwk.x), algorithm, extractable, keyUsages);\r\n                }\r\n            }\r\n            case \"raw\": {\r\n                return this.importPublicKey(keyData, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"spki\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\r\n                return this.importPublicKey(keyInfo.publicKey, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"pkcs8\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\r\n                const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);\r\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const key = new EdPrivateKey();\r\n        key.fromJSON({\r\n            crv: algorithm.namedCurve,\r\n            d: pvtsutils.Convert.ToBase64Url(asnKey.d),\r\n        });\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const key = new EdPublicKey();\r\n        key.fromJSON({\r\n            crv: algorithm.namedCurve,\r\n            x: pvtsutils.Convert.ToBase64Url(asnKey),\r\n        });\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n}\r\nEdCrypto.publicKeyUsages = [\"verify\"];\r\nEdCrypto.privateKeyUsages = [\"sign\", \"deriveKey\", \"deriveBits\"];\n\nclass EdDsaProvider extends core__namespace.EdDsaProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await EdCrypto.generateKey({\r\n            name: this.name,\r\n            namedCurve: algorithm.namedCurve.replace(/^ed/i, \"Ed\"),\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        return EdCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        return EdCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return EdCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await EdCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n}\n\nclass EcdhEsProvider extends core__namespace.EcdhEsProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await EdCrypto.generateKey({\r\n            name: this.name,\r\n            namedCurve: algorithm.namedCurve.toUpperCase(),\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onDeriveBits(algorithm, baseKey, length) {\r\n        const bits = await EdCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);\r\n        return bits;\r\n    }\r\n    async onExportKey(format, key) {\r\n        return EdCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await EdCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n}\n\nclass PbkdfCryptoKey extends CryptoKey {\r\n}\n\nclass Pbkdf2Provider extends core__namespace.Pbkdf2Provider {\r\n    async onDeriveBits(algorithm, baseKey, length) {\r\n        return new Promise((resolve, reject) => {\r\n            const salt = core__namespace.BufferSourceConverter.toArrayBuffer(algorithm.salt);\r\n            const hash = algorithm.hash.name.replace(\"-\", \"\");\r\n            crypto.pbkdf2(getCryptoKey(baseKey).data, Buffer.from(salt), algorithm.iterations, length >> 3, hash, (err, derivedBits) => {\r\n                if (err) {\r\n                    reject(err);\r\n                }\r\n                else {\r\n                    resolve(new Uint8Array(derivedBits).buffer);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        if (format === \"raw\") {\r\n            const key = new PbkdfCryptoKey();\r\n            key.data = Buffer.from(keyData);\r\n            key.algorithm = { name: this.name };\r\n            key.extractable = false;\r\n            key.usages = keyUsages;\r\n            return setCryptoKey(key);\r\n        }\r\n        throw new core__namespace.OperationError(\"format: Must be 'raw'\");\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof PbkdfCryptoKey)) {\r\n            throw new TypeError(\"key: Is not PBKDF CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass HmacCryptoKey extends CryptoKey {\r\n    get alg() {\r\n        const hash = this.algorithm.hash.name.toUpperCase();\r\n        return `HS${hash.replace(\"SHA-\", \"\")}`;\r\n    }\r\n    set alg(value) {\r\n    }\r\n}\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ name: \"k\", converter: JsonBase64UrlConverter })\r\n], HmacCryptoKey.prototype, \"data\", void 0);\n\nclass HmacProvider extends core__namespace.HmacProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const length = (algorithm.length || this.getDefaultLength(algorithm.hash.name)) >> 3 << 3;\r\n        const key = new HmacCryptoKey();\r\n        key.algorithm = {\r\n            ...algorithm,\r\n            length,\r\n            name: this.name,\r\n        };\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        key.data = crypto.randomBytes(length >> 3);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);\r\n        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data)\r\n            .update(Buffer.from(data)).digest();\r\n        return new Uint8Array(hmac).buffer;\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);\r\n        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data)\r\n            .update(Buffer.from(data)).digest();\r\n        return hmac.compare(Buffer.from(signature)) === 0;\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        let key;\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                key = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: HmacCryptoKey });\r\n                break;\r\n            case \"raw\":\r\n                key = new HmacCryptoKey();\r\n                key.data = Buffer.from(keyData);\r\n                break;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n        key.algorithm = {\r\n            hash: { name: algorithm.hash.name },\r\n            name: this.name,\r\n            length: key.data.length << 3,\r\n        };\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return setCryptoKey(key);\r\n    }\r\n    async onExportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(getCryptoKey(key));\r\n            case \"raw\":\r\n                return new Uint8Array(getCryptoKey(key).data).buffer;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof HmacCryptoKey)) {\r\n            throw new TypeError(\"key: Is not HMAC CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass HkdfCryptoKey extends CryptoKey {\r\n}\n\nclass HkdfProvider extends core__namespace.HkdfProvider {\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        if (format.toLowerCase() !== \"raw\") {\r\n            throw new core__namespace.OperationError(\"Operation not supported\");\r\n        }\r\n        const key = new HkdfCryptoKey();\r\n        key.data = Buffer.from(keyData);\r\n        key.algorithm = { name: this.name };\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return setCryptoKey(key);\r\n    }\r\n    async onDeriveBits(params, baseKey, length) {\r\n        const hash = params.hash.name.replace(\"-\", \"\");\r\n        const hashLength = crypto.createHash(hash).digest().length;\r\n        const byteLength = length / 8;\r\n        const info = core.BufferSourceConverter.toUint8Array(params.info);\r\n        const PRK = crypto.createHmac(hash, core.BufferSourceConverter.toUint8Array(params.salt))\r\n            .update(core.BufferSourceConverter.toUint8Array(getCryptoKey(baseKey).data))\r\n            .digest();\r\n        const blocks = [Buffer.alloc(0)];\r\n        const blockCount = Math.ceil(byteLength / hashLength) + 1;\r\n        for (let i = 1; i < blockCount; ++i) {\r\n            blocks.push(crypto.createHmac(hash, PRK)\r\n                .update(Buffer.concat([blocks[i - 1], info, Buffer.from([i])]))\r\n                .digest());\r\n        }\r\n        return Buffer.concat(blocks).slice(0, byteLength);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof HkdfCryptoKey)) {\r\n            throw new TypeError(\"key: Is not HKDF CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass ShakeCrypto {\r\n    static digest(algorithm, data) {\r\n        const hash = crypto.createHash(algorithm.name.toLowerCase(), { outputLength: algorithm.length })\r\n            .update(Buffer.from(data)).digest();\r\n        return new Uint8Array(hash).buffer;\r\n    }\r\n}\n\nclass Shake128Provider extends core__namespace.Shake128Provider {\r\n    async onDigest(algorithm, data) {\r\n        return ShakeCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Shake256Provider extends core__namespace.Shake256Provider {\r\n    async onDigest(algorithm, data) {\r\n        return ShakeCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass SubtleCrypto extends core__namespace.SubtleCrypto {\r\n    constructor() {\r\n        var _a;\r\n        super();\r\n        this.providers.set(new AesCbcProvider());\r\n        this.providers.set(new AesCtrProvider());\r\n        this.providers.set(new AesGcmProvider());\r\n        this.providers.set(new AesCmacProvider());\r\n        this.providers.set(new AesKwProvider());\r\n        this.providers.set(new AesEcbProvider());\r\n        this.providers.set(new DesCbcProvider());\r\n        this.providers.set(new DesEde3CbcProvider());\r\n        this.providers.set(new RsaSsaProvider());\r\n        this.providers.set(new RsaPssProvider());\r\n        this.providers.set(new RsaOaepProvider());\r\n        this.providers.set(new RsaEsProvider());\r\n        this.providers.set(new EcdsaProvider());\r\n        this.providers.set(new EcdhProvider());\r\n        this.providers.set(new Sha1Provider());\r\n        this.providers.set(new Sha256Provider());\r\n        this.providers.set(new Sha384Provider());\r\n        this.providers.set(new Sha512Provider());\r\n        this.providers.set(new Pbkdf2Provider());\r\n        this.providers.set(new HmacProvider());\r\n        this.providers.set(new HkdfProvider());\r\n        const nodeMajorVersion = (_a = /^v(\\d+)/.exec(process__namespace.version)) === null || _a === void 0 ? void 0 : _a[1];\r\n        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 12) {\r\n            this.providers.set(new Shake128Provider());\r\n            this.providers.set(new Shake256Provider());\r\n        }\r\n        const hashes = crypto__namespace.getHashes();\r\n        if (hashes.includes(\"sha3-256\")) {\r\n            this.providers.set(new Sha3256Provider());\r\n        }\r\n        if (hashes.includes(\"sha3-384\")) {\r\n            this.providers.set(new Sha3384Provider());\r\n        }\r\n        if (hashes.includes(\"sha3-512\")) {\r\n            this.providers.set(new Sha3512Provider());\r\n        }\r\n        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 14) {\r\n            this.providers.set(new EdDsaProvider());\r\n            this.providers.set(new EcdhEsProvider());\r\n        }\r\n    }\r\n}\n\nclass Crypto extends core__namespace.Crypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.subtle = new SubtleCrypto();\r\n    }\r\n    getRandomValues(array) {\r\n        if (!ArrayBuffer.isView(array)) {\r\n            throw new TypeError(\"Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'\");\r\n        }\r\n        const buffer = Buffer.from(array.buffer, array.byteOffset, array.byteLength);\r\n        crypto.randomFillSync(buffer);\r\n        return array;\r\n    }\r\n}\n\nObject.defineProperty(exports, \"CryptoKey\", ({\n  enumerable: true,\n  get: function () { return core.CryptoKey; }\n}));\nexports.Crypto = Crypto;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL3dlYmNyeXB0by9idWlsZC93ZWJjcnlwdG8uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxtRkFBZ0I7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyx3QkFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMsdURBQU87QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsd0ZBQXVCO0FBQ2hELGdCQUFnQixtQkFBTyxDQUFDLGdFQUFXO0FBQ25DLGlCQUFpQixtQkFBTyxDQUFDLDRGQUF1Qjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUVBQXFFO0FBQy9GO0FBQ0E7QUFDQSwwQkFBMEIsd0ZBQXdGO0FBQ2xIO0FBQ0E7QUFDQSwwQkFBMEIsdUNBQXVDO0FBQ2pFO0FBQ0E7QUFDQSwwQkFBMEIsdURBQXVEO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBOEM7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDRCQUE0QjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxxQkFBcUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHFCQUFxQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFxQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QscUJBQXFCO0FBQ3pFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxxQkFBcUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHFCQUFxQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFxQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxzQkFBc0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZ0JBQWdCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHNCQUFzQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsc0JBQXNCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxzQkFBc0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHNCQUFzQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsc0JBQXNCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOENBQThDO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsNEJBQTRCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwyQ0FBMkM7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDJDQUEyQztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscUJBQXFCLE9BQU8sT0FBTztBQUNqRTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBLHdCQUF3QixzQ0FBc0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsa0RBQWtEO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaURBQWlEO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsa0RBQWtEO0FBQy9IO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxpREFBaUQ7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsNEJBQTRCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDRCQUE0QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw0QkFBNEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsNEJBQTRCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLCtCQUErQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsK0JBQStCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELG9DQUFvQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG9DQUFvQztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwrQkFBK0I7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwrQkFBK0I7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU0sWUFBWSwwQ0FBMEMsYUFBYSxNQUFNO0FBQzlHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsV0FBVztBQUNyRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxpREFBaUQ7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdEQUFnRDtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDRCQUE0QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDRCQUE0QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxpREFBaUQ7QUFDOUg7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGdEQUFnRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwrQkFBK0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwrQkFBK0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0RBQXNEO0FBQ3ZHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixXQUFXO0FBQ3JHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxvREFBb0Q7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsNEJBQTRCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw0QkFBNEI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxvREFBb0Q7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLCtCQUErQjtBQUMvRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0RBQXNEO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwrQkFBK0I7QUFDL0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBOEM7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDZCQUE2QjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1RUFBdUUsZ0NBQWdDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE0QztBQUM1QztBQUNBLHFCQUFxQjtBQUNyQixDQUFDLEVBQUM7QUFDRixjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhcnR1cC1uZXh0anMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL3dlYmNyeXB0by9idWlsZC93ZWJjcnlwdG8uanM/NzVhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiBDb3B5cmlnaHQgKGMpIFBlY3VsaWFyIFZlbnR1cmVzLCBMTENcbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNvcmUgPSByZXF1aXJlKCd3ZWJjcnlwdG8tY29yZScpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIHByb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzJyk7XG52YXIgdHNsaWIgPSByZXF1aXJlKCd0c2xpYicpO1xudmFyIGpzb25TY2hlbWEgPSByZXF1aXJlKCdAcGVjdWxpYXIvanNvbi1zY2hlbWEnKTtcbnZhciBwdnRzdXRpbHMgPSByZXF1aXJlKCdwdnRzdXRpbHMnKTtcbnZhciBhc24xU2NoZW1hID0gcmVxdWlyZSgnQHBlY3VsaWFyL2FzbjEtc2NoZW1hJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChlKSB7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuLmRlZmF1bHQgPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIGNvcmVfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoY29yZSk7XG52YXIgY3J5cHRvX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KGNyeXB0byk7XG52YXIgcHJvY2Vzc19fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChwcm9jZXNzKTtcblxuY29uc3QgSnNvbkJhc2U2NFVybENvbnZlcnRlciA9IHtcclxuICAgIGZyb21KU09OOiAodmFsdWUpID0+IEJ1ZmZlci5mcm9tKHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwodmFsdWUpKSxcclxuICAgIHRvSlNPTjogKHZhbHVlKSA9PiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybCh2YWx1ZSksXHJcbn07XG5cbmNsYXNzIENyeXB0b0tleSBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5DcnlwdG9LZXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIuYWxsb2MoMCk7XHJcbiAgICAgICAgdGhpcy5hbGdvcml0aG0gPSB7IG5hbWU6IFwiXCIgfTtcclxuICAgICAgICB0aGlzLmV4dHJhY3RhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJzZWNyZXRcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMua3R5ID0gXCJvY3RcIjtcclxuICAgICAgICB0aGlzLmFsZyA9IFwiXCI7XHJcbiAgICB9XHJcbn1cclxudHNsaWIuX19kZWNvcmF0ZShbXHJcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJleHRcIiwgdHlwZToganNvblNjaGVtYS5Kc29uUHJvcFR5cGVzLkJvb2xlYW4sIG9wdGlvbmFsOiB0cnVlIH0pXHJcbl0sIENyeXB0b0tleS5wcm90b3R5cGUsIFwiZXh0cmFjdGFibGVcIiwgdm9pZCAwKTtcclxudHNsaWIuX19kZWNvcmF0ZShbXHJcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJrZXlfb3BzXCIsIHR5cGU6IGpzb25TY2hlbWEuSnNvblByb3BUeXBlcy5TdHJpbmcsIHJlcGVhdGVkOiB0cnVlLCBvcHRpb25hbDogdHJ1ZSB9KVxyXG5dLCBDcnlwdG9LZXkucHJvdG90eXBlLCBcInVzYWdlc1wiLCB2b2lkIDApO1xyXG50c2xpYi5fX2RlY29yYXRlKFtcclxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyB0eXBlOiBqc29uU2NoZW1hLkpzb25Qcm9wVHlwZXMuU3RyaW5nIH0pXHJcbl0sIENyeXB0b0tleS5wcm90b3R5cGUsIFwia3R5XCIsIHZvaWQgMCk7XHJcbnRzbGliLl9fZGVjb3JhdGUoW1xyXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IHR5cGU6IGpzb25TY2hlbWEuSnNvblByb3BUeXBlcy5TdHJpbmcsIG9wdGlvbmFsOiB0cnVlIH0pXHJcbl0sIENyeXB0b0tleS5wcm90b3R5cGUsIFwiYWxnXCIsIHZvaWQgMCk7XG5cbmNsYXNzIFN5bW1ldHJpY0tleSBleHRlbmRzIENyeXB0b0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMua3R5ID0gXCJvY3RcIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInNlY3JldFwiO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEFzeW1tZXRyaWNLZXkgZXh0ZW5kcyBDcnlwdG9LZXkge1xyXG59XG5cbmNsYXNzIEFlc0NyeXB0b0tleSBleHRlbmRzIFN5bW1ldHJpY0tleSB7XHJcbiAgICBnZXQgYWxnKCkge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5hbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtQ0JDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYEEke3RoaXMuYWxnb3JpdGhtLmxlbmd0aH1DQkNgO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNUUlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBBJHt0aGlzLmFsZ29yaXRobS5sZW5ndGh9Q1RSYDtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1HQ01cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUdDTWA7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtS1dcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUtXYDtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1DTUFDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYEEke3RoaXMuYWxnb3JpdGhtLmxlbmd0aH1DTUFDYDtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1FQ0JcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUVDQmA7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLkFsZ29yaXRobUVycm9yKFwiVW5zdXBwb3J0ZWQgYWxnb3JpdGhtIG5hbWVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0IGFsZyh2YWx1ZSkge1xyXG4gICAgfVxyXG59XHJcbnRzbGliLl9fZGVjb3JhdGUoW1xyXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwia1wiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxDb252ZXJ0ZXIgfSlcclxuXSwgQWVzQ3J5cHRvS2V5LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG5cbmNvbnN0IGtleVN0b3JhZ2UgPSBuZXcgV2Vha01hcCgpO1xyXG5mdW5jdGlvbiBnZXRDcnlwdG9LZXkoa2V5KSB7XHJcbiAgICBjb25zdCByZXMgPSBrZXlTdG9yYWdlLmdldChrZXkpO1xyXG4gICAgaWYgKCFyZXMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiQ2Fubm90IGdldCBDcnlwdG9LZXkgZnJvbSBzZWN1cmUgc3RvcmFnZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gc2V0Q3J5cHRvS2V5KHZhbHVlKSB7XHJcbiAgICBjb25zdCBrZXkgPSBjb3JlX19uYW1lc3BhY2UuQ3J5cHRvS2V5LmNyZWF0ZSh2YWx1ZS5hbGdvcml0aG0sIHZhbHVlLnR5cGUsIHZhbHVlLmV4dHJhY3RhYmxlLCB2YWx1ZS51c2FnZXMpO1xyXG4gICAgT2JqZWN0LmZyZWV6ZShrZXkpO1xyXG4gICAga2V5U3RvcmFnZS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICByZXR1cm4ga2V5O1xyXG59XG5cbmNsYXNzIEFlc0NyeXB0byB7XHJcbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEFlc0NyeXB0b0tleSgpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICBrZXkuZGF0YSA9IGNyeXB0by5yYW5kb21CeXRlcyhhbGdvcml0aG0ubGVuZ3RoID4+IDMpO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXk6IElzIG5vdCBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShrZXkuZGF0YSkuYnVmZmVyO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJyBvciAncmF3J1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgbGV0IGtleTtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogQWVzQ3J5cHRvS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IG5ldyBBZXNDcnlwdG9LZXkoKTtcclxuICAgICAgICAgICAgICAgIGtleS5kYXRhID0gQnVmZmVyLmZyb20oa2V5RGF0YSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycgb3IgJ3JhdydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAga2V5LmFsZ29yaXRobS5sZW5ndGggPSBrZXkuZGF0YS5sZW5ndGggPDwgMztcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY2FzZSAxMjg6XHJcbiAgICAgICAgICAgIGNhc2UgMTkyOlxyXG4gICAgICAgICAgICBjYXNlIDI1NjpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImtleURhdGE6IElzIHdyb25nIGtleSBsZW5ndGhcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdEFlc0NCQyhhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNUUlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdEFlc0NUUihhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUdDTVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdEFlc0dDTShhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUtXXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0QWVzS1coYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1FQ0JcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRBZXNFQ0IoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXk6IElzIG5vdCBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdEFlc0NCQyhhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNUUlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdEFlc0NUUihhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUdDTVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdEFlc0dDTShhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUtXXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0QWVzS1coYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1FQ0JcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRBZXNFQ0IoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0QWVzQ0JDKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tY2JjYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5pdikpO1xyXG4gICAgICAgIGxldCBlbmMgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGVuYyA9IEJ1ZmZlci5jb25jYXQoW2VuYywgY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHRBZXNDQkMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tY2JjYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5pdikpO1xyXG4gICAgICAgIGxldCBkZWMgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZGVjID0gQnVmZmVyLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHRBZXNDVFIoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1jdHJgLCBrZXkuZGF0YSwgQnVmZmVyLmZyb20oYWxnb3JpdGhtLmNvdW50ZXIpKTtcclxuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBlbmMgPSBCdWZmZXIuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0QWVzQ1RSKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWN0cmAsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheShhbGdvcml0aG0uY291bnRlcikpO1xyXG4gICAgICAgIGxldCBkZWMgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZGVjID0gQnVmZmVyLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHRBZXNHQ00oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1nY21gLCBrZXkuZGF0YSwgQnVmZmVyLmZyb20oYWxnb3JpdGhtLml2KSwge1xyXG4gICAgICAgICAgICBhdXRoVGFnTGVuZ3RoOiAoYWxnb3JpdGhtLnRhZ0xlbmd0aCB8fCAxMjgpID4+IDMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGFsZ29yaXRobS5hZGRpdGlvbmFsRGF0YSkge1xyXG4gICAgICAgICAgICBjaXBoZXIuc2V0QUFEKEJ1ZmZlci5mcm9tKGFsZ29yaXRobS5hZGRpdGlvbmFsRGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBlbmMgPSBCdWZmZXIuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpLCBjaXBoZXIuZ2V0QXV0aFRhZygpXSk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0QWVzR0NNKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWdjbWAsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheShhbGdvcml0aG0uaXYpKTtcclxuICAgICAgICBjb25zdCB0YWdMZW5ndGggPSAoYWxnb3JpdGhtLnRhZ0xlbmd0aCB8fCAxMjgpID4+IDM7XHJcbiAgICAgICAgY29uc3QgZW5jID0gZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIHRhZ0xlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgdGFnID0gZGF0YS5zbGljZShkYXRhLmxlbmd0aCAtIHRhZ0xlbmd0aCk7XHJcbiAgICAgICAgaWYgKGFsZ29yaXRobS5hZGRpdGlvbmFsRGF0YSkge1xyXG4gICAgICAgICAgICBkZWNpcGhlci5zZXRBQUQoQnVmZmVyLmZyb20oYWxnb3JpdGhtLmFkZGl0aW9uYWxEYXRhKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlY2lwaGVyLnNldEF1dGhUYWcodGFnKTtcclxuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGVuYyk7XHJcbiAgICAgICAgZGVjID0gQnVmZmVyLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHRBZXNLVyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihgaWQtYWVzJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0td3JhcGAsIGtleS5kYXRhLCB0aGlzLkFFU19LV19JVik7XHJcbiAgICAgICAgbGV0IGVuYyA9IGNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZW5jID0gQnVmZmVyLmNvbmNhdChbZW5jLCBjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0QWVzS1coYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBpZC1hZXMke2tleS5hbGdvcml0aG0ubGVuZ3RofS13cmFwYCwga2V5LmRhdGEsIHRoaXMuQUVTX0tXX0lWKTtcclxuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGRlYyA9IEJ1ZmZlci5jb25jYXQoW2RlYywgZGVjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0QWVzRUNCKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tZWNiYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KDApKTtcclxuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBlbmMgPSBCdWZmZXIuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0QWVzRUNCKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWVjYmAsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheSgwKSk7XHJcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBkZWMgPSBCdWZmZXIuY29uY2F0KFtkZWMsIGRlY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XHJcbiAgICB9XHJcbn1cclxuQWVzQ3J5cHRvLkFFU19LV19JViA9IEJ1ZmZlci5mcm9tKFwiQTZBNkE2QTZBNkE2QTZBNlwiLCBcImhleFwiKTtcblxuY2xhc3MgQWVzQ2JjUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQWVzQ2JjUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmVuY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5kZWNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEFlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IGFsZ29yaXRobS5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgQWVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jb25zdCB6ZXJvID0gQnVmZmVyLmZyb20oWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcclxuY29uc3QgcmIgPSBCdWZmZXIuZnJvbShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMTM1XSk7XHJcbmNvbnN0IGJsb2NrU2l6ZSA9IDE2O1xyXG5mdW5jdGlvbiBiaXRTaGlmdExlZnQoYnVmZmVyKSB7XHJcbiAgICBjb25zdCBzaGlmdGVkID0gQnVmZmVyLmFsbG9jKGJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgY29uc3QgbGFzdCA9IGJ1ZmZlci5sZW5ndGggLSAxO1xyXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxhc3Q7IGluZGV4KyspIHtcclxuICAgICAgICBzaGlmdGVkW2luZGV4XSA9IGJ1ZmZlcltpbmRleF0gPDwgMTtcclxuICAgICAgICBpZiAoYnVmZmVyW2luZGV4ICsgMV0gJiAweDgwKSB7XHJcbiAgICAgICAgICAgIHNoaWZ0ZWRbaW5kZXhdICs9IDB4MDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2hpZnRlZFtsYXN0XSA9IGJ1ZmZlcltsYXN0XSA8PCAxO1xyXG4gICAgcmV0dXJuIHNoaWZ0ZWQ7XHJcbn1cclxuZnVuY3Rpb24geG9yKGEsIGIpIHtcclxuICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICBvdXRwdXRbaW5kZXhdID0gYVtpbmRleF0gXiBiW2luZGV4XTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuZnVuY3Rpb24gYWVzKGtleSwgbWVzc2FnZSkge1xyXG4gICAgY29uc3QgY2lwaGVyID0gY3J5cHRvX19uYW1lc3BhY2UuY3JlYXRlQ2lwaGVyaXYoYGFlcyR7a2V5Lmxlbmd0aCA8PCAzfWAsIGtleSwgemVybyk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBjaXBoZXIudXBkYXRlKG1lc3NhZ2UpO1xyXG4gICAgY2lwaGVyLmZpbmFsKCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGdldE1lc3NhZ2VCbG9jayhtZXNzYWdlLCBibG9ja0luZGV4KSB7XHJcbiAgICBjb25zdCBibG9jayA9IEJ1ZmZlci5hbGxvYyhibG9ja1NpemUpO1xyXG4gICAgY29uc3Qgc3RhcnQgPSBibG9ja0luZGV4ICogYmxvY2tTaXplO1xyXG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBibG9ja1NpemU7XHJcbiAgICBtZXNzYWdlLmNvcHkoYmxvY2ssIDAsIHN0YXJ0LCBlbmQpO1xyXG4gICAgcmV0dXJuIGJsb2NrO1xyXG59XHJcbmZ1bmN0aW9uIGdldFBhZGRlZE1lc3NhZ2VCbG9jayhtZXNzYWdlLCBibG9ja0luZGV4KSB7XHJcbiAgICBjb25zdCBibG9jayA9IEJ1ZmZlci5hbGxvYyhibG9ja1NpemUpO1xyXG4gICAgY29uc3Qgc3RhcnQgPSBibG9ja0luZGV4ICogYmxvY2tTaXplO1xyXG4gICAgY29uc3QgZW5kID0gbWVzc2FnZS5sZW5ndGg7XHJcbiAgICBibG9jay5maWxsKDApO1xyXG4gICAgbWVzc2FnZS5jb3B5KGJsb2NrLCAwLCBzdGFydCwgZW5kKTtcclxuICAgIGJsb2NrW2VuZCAtIHN0YXJ0XSA9IDB4ODA7XHJcbiAgICByZXR1cm4gYmxvY2s7XHJcbn1cclxuZnVuY3Rpb24gZ2VuZXJhdGVTdWJrZXlzKGtleSkge1xyXG4gICAgY29uc3QgbCA9IGFlcyhrZXksIHplcm8pO1xyXG4gICAgbGV0IHN1YmtleTEgPSBiaXRTaGlmdExlZnQobCk7XHJcbiAgICBpZiAobFswXSAmIDB4ODApIHtcclxuICAgICAgICBzdWJrZXkxID0geG9yKHN1YmtleTEsIHJiKTtcclxuICAgIH1cclxuICAgIGxldCBzdWJrZXkyID0gYml0U2hpZnRMZWZ0KHN1YmtleTEpO1xyXG4gICAgaWYgKHN1YmtleTFbMF0gJiAweDgwKSB7XHJcbiAgICAgICAgc3Via2V5MiA9IHhvcihzdWJrZXkyLCByYik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBzdWJrZXkxLCBzdWJrZXkyIH07XHJcbn1cclxuZnVuY3Rpb24gYWVzQ21hYyhrZXksIG1lc3NhZ2UpIHtcclxuICAgIGNvbnN0IHN1YmtleXMgPSBnZW5lcmF0ZVN1YmtleXMoa2V5KTtcclxuICAgIGxldCBibG9ja0NvdW50ID0gTWF0aC5jZWlsKG1lc3NhZ2UubGVuZ3RoIC8gYmxvY2tTaXplKTtcclxuICAgIGxldCBsYXN0QmxvY2tDb21wbGV0ZUZsYWc7XHJcbiAgICBsZXQgbGFzdEJsb2NrO1xyXG4gICAgaWYgKGJsb2NrQ291bnQgPT09IDApIHtcclxuICAgICAgICBibG9ja0NvdW50ID0gMTtcclxuICAgICAgICBsYXN0QmxvY2tDb21wbGV0ZUZsYWcgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxhc3RCbG9ja0NvbXBsZXRlRmxhZyA9IChtZXNzYWdlLmxlbmd0aCAlIGJsb2NrU2l6ZSA9PT0gMCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsYXN0QmxvY2tJbmRleCA9IGJsb2NrQ291bnQgLSAxO1xyXG4gICAgaWYgKGxhc3RCbG9ja0NvbXBsZXRlRmxhZykge1xyXG4gICAgICAgIGxhc3RCbG9jayA9IHhvcihnZXRNZXNzYWdlQmxvY2sobWVzc2FnZSwgbGFzdEJsb2NrSW5kZXgpLCBzdWJrZXlzLnN1YmtleTEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGFzdEJsb2NrID0geG9yKGdldFBhZGRlZE1lc3NhZ2VCbG9jayhtZXNzYWdlLCBsYXN0QmxvY2tJbmRleCksIHN1YmtleXMuc3Via2V5Mik7XHJcbiAgICB9XHJcbiAgICBsZXQgeCA9IHplcm87XHJcbiAgICBsZXQgeTtcclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsYXN0QmxvY2tJbmRleDsgaW5kZXgrKykge1xyXG4gICAgICAgIHkgPSB4b3IoeCwgZ2V0TWVzc2FnZUJsb2NrKG1lc3NhZ2UsIGluZGV4KSk7XHJcbiAgICAgICAgeCA9IGFlcyhrZXksIHkpO1xyXG4gICAgfVxyXG4gICAgeSA9IHhvcihsYXN0QmxvY2ssIHgpO1xyXG4gICAgcmV0dXJuIGFlcyhrZXksIHkpO1xyXG59XHJcbmNsYXNzIEFlc0NtYWNQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5BZXNDbWFjUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhZXNDbWFjKGdldENyeXB0b0tleShrZXkpLmRhdGEsIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlMiA9IGF3YWl0IHRoaXMuc2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkuY29tcGFyZShCdWZmZXIuZnJvbShzaWduYXR1cmUyKSkgPT09IDA7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KHJlcyk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBBZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEFlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgQWVzQ3RyUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQWVzQ3RyUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmVuY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5kZWNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IEFlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IGFsZ29yaXRobS5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkocmVzKTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgQWVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBBZXNHY21Qcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5BZXNHY21Qcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEFlc0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiBhbGdvcml0aG0ubGVuZ3RoLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgQWVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogYWxnb3JpdGhtLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShyZXMpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEFlc0t3UHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQWVzS3dQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IEFlc0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiBhbGdvcml0aG0ubGVuZ3RoLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkocmVzKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IEFlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IGFsZ29yaXRobS5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkocmVzKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEFlc0VjYlByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkFlc0VjYlByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgQWVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IGFsZ29yaXRobS5sZW5ndGgsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5lbmNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZGVjcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KHJlcyk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBBZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEFlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRGVzQ3J5cHRvS2V5IGV4dGVuZHMgU3ltbWV0cmljS2V5IHtcclxuICAgIGdldCBhbGcoKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIkRFUy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgREVTLUNCQ2A7XHJcbiAgICAgICAgICAgIGNhc2UgXCJERVMtRURFMy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgM0RFUy1DQkNgO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5BbGdvcml0aG1FcnJvcihcIlVuc3VwcG9ydGVkIGFsZ29yaXRobSBuYW1lXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldCBhbGcodmFsdWUpIHtcclxuICAgIH1cclxufVxyXG50c2xpYi5fX2RlY29yYXRlKFtcclxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImtcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQ29udmVydGVyIH0pXHJcbl0sIERlc0NyeXB0b0tleS5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuXG5jbGFzcyBEZXNDcnlwdG8ge1xyXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBEZXNDcnlwdG9LZXkoKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAga2V5LmRhdGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoYWxnb3JpdGhtLmxlbmd0aCA+PiAzKTtcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShrZXkuZGF0YSkuYnVmZmVyO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJyBvciAncmF3J1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgbGV0IGtleTtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogRGVzQ3J5cHRvS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IG5ldyBEZXNDcnlwdG9LZXkoKTtcclxuICAgICAgICAgICAgICAgIGtleS5kYXRhID0gQnVmZmVyLmZyb20oa2V5RGF0YSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycgb3IgJ3JhdydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIkRFUy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHREZXNDQkMoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkRFUy1FREUzLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdERlc0VERTNDQkMoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluc3RhbmNlb2YgRGVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXk6IElzIG5vdCBEZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiREVTLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdERlc0NCQyhhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiREVTLUVERTMtQ0JDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0RGVzRURFM0NCQyhhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHREZXNDQkMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGRlcy1jYmNgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLml2KSk7XHJcbiAgICAgICAgbGV0IGVuYyA9IGNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZW5jID0gQnVmZmVyLmNvbmNhdChbZW5jLCBjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGVuYykuYnVmZmVyO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdERlc0NCQyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYGRlcy1jYmNgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLml2KSk7XHJcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBkZWMgPSBCdWZmZXIuY29uY2F0KFtkZWMsIGRlY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdERlc0VERTNDQkMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGRlcy1lZGUzLWNiY2AsIGtleS5kYXRhLCBCdWZmZXIuZnJvbShhbGdvcml0aG0uaXYpKTtcclxuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBlbmMgPSBCdWZmZXIuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0RGVzRURFM0NCQyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYGRlcy1lZGUzLWNiY2AsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheShhbGdvcml0aG0uaXYpKTtcclxuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGRlYyA9IEJ1ZmZlci5jb25jYXQoW2RlYywgZGVjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcclxuICAgIH1cclxufVxuXG5jbGFzcyBEZXNDYmNQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5EZXNQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMua2V5U2l6ZUJpdHMgPSA2NDtcclxuICAgICAgICB0aGlzLml2U2l6ZSA9IDg7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJERVMtQ0JDXCI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IERlc0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLmtleVNpemVCaXRzLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBEZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gRGVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gRGVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRGVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogdGhpcy5uYW1lLCBsZW5ndGg6IHRoaXMua2V5U2l6ZUJpdHMgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgaWYgKGtleS5kYXRhLmxlbmd0aCAhPT0gKHRoaXMua2V5U2l6ZUJpdHMgPj4gMykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImtleURhdGE6IFdyb25nIGtleSBzaXplXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBEZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIERlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRGVzRWRlM0NiY1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkRlc1Byb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5rZXlTaXplQml0cyA9IDE5MjtcclxuICAgICAgICB0aGlzLml2U2l6ZSA9IDg7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJERVMtRURFMy1DQkNcIjtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRGVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMua2V5U2l6ZUJpdHMsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIERlc0NyeXB0by5lbmNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBEZXNDcnlwdG8uZGVjcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBEZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBEZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiB0aGlzLm5hbWUsIGxlbmd0aDogdGhpcy5rZXlTaXplQml0cyB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICBpZiAoa2V5LmRhdGEubGVuZ3RoICE9PSAodGhpcy5rZXlTaXplQml0cyA+PiAzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwia2V5RGF0YTogV3Jvbmcga2V5IHNpemVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIERlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgRGVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBnZXRKd2tBbGdvcml0aG0oYWxnb3JpdGhtKSB7XHJcbiAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICBjYXNlIFwiUlNBLU9BRVBcIjoge1xyXG4gICAgICAgICAgICBjb25zdCBtZFNpemUgPSAvKFxcZCspJC8uZXhlYyhhbGdvcml0aG0uaGFzaC5uYW1lKVsxXTtcclxuICAgICAgICAgICAgcmV0dXJuIGBSU0EtT0FFUCR7bWRTaXplICE9PSBcIjFcIiA/IGAtJHttZFNpemV9YCA6IFwiXCJ9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcIlJTQVNTQS1QS0NTMS1WMV81XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBgUlMkey8oXFxkKykkLy5leGVjKGFsZ29yaXRobS5oYXNoLm5hbWUpWzFdfWA7XHJcbiAgICAgICAgY2FzZSBcIlJTQS1QU1NcIjpcclxuICAgICAgICAgICAgcmV0dXJuIGBQUyR7LyhcXGQrKSQvLmV4ZWMoYWxnb3JpdGhtLmhhc2gubmFtZSlbMV19YDtcclxuICAgICAgICBjYXNlIFwiUlNBLVBLQ1MxXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBgUlMxYDtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBSc2FQcml2YXRlS2V5IGV4dGVuZHMgQXN5bW1ldHJpY0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicHJpdmF0ZVwiO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZSh0aGlzLmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICByZXR1cm4gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5SW5mby5wcml2YXRlS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQcml2YXRlS2V5KTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xyXG4gICAgICAgIGNvbnN0IGpzb24gPSB7XHJcbiAgICAgICAgICAgIGt0eTogXCJSU0FcIixcclxuICAgICAgICAgICAgYWxnOiBnZXRKd2tBbGdvcml0aG0odGhpcy5hbGdvcml0aG0pLFxyXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcclxuICAgICAgICAgICAgZXh0OiB0aGlzLmV4dHJhY3RhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oanNvbiwganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KSk7XHJcbiAgICB9XHJcbiAgICBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGpzb24sIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQcml2YXRlS2V5IH0pO1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjExMzU0OS4xLjEuMVwiO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gbnVsbDtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXkgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleSk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUnNhUHVibGljS2V5IGV4dGVuZHMgQXN5bW1ldHJpY0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicHVibGljXCI7XHJcbiAgICB9XHJcbiAgICBnZXRLZXkoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHVibGljS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQdWJsaWNLZXkpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KCk7XHJcbiAgICAgICAgY29uc3QganNvbiA9IHtcclxuICAgICAgICAgICAga3R5OiBcIlJTQVwiLFxyXG4gICAgICAgICAgICBhbGc6IGdldEp3a0FsZ29yaXRobSh0aGlzLmFsZ29yaXRobSksXHJcbiAgICAgICAgICAgIGtleV9vcHM6IHRoaXMudXNhZ2VzLFxyXG4gICAgICAgICAgICBleHQ6IHRoaXMuZXh0cmFjdGFibGUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihqc29uLCBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpKTtcclxuICAgIH1cclxuICAgIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oanNvbiwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLlJzYVB1YmxpY0tleSB9KTtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5hbGdvcml0aG0gPSBcIjEuMi44NDAuMTEzNTQ5LjEuMS4xXCI7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IG51bGw7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXkgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleSk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUnNhQ3J5cHRvIHtcclxuICAgIHN0YXRpYyBhc3luYyBnZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gbmV3IFJzYVByaXZhdGVLZXkoKTtcclxuICAgICAgICBwcml2YXRlS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBwcml2YXRlS2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAgcHJpdmF0ZUtleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wcml2YXRlS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XHJcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IFJzYVB1YmxpY0tleSgpO1xyXG4gICAgICAgIHB1YmxpY0tleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAgcHVibGljS2V5LmV4dHJhY3RhYmxlID0gdHJ1ZTtcclxuICAgICAgICBwdWJsaWNLZXkudXNhZ2VzID0ga2V5VXNhZ2VzLmZpbHRlcigodXNhZ2UpID0+IHRoaXMucHVibGljS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XHJcbiAgICAgICAgY29uc3QgcHVibGljRXhwb25lbnQgPSBCdWZmZXIuY29uY2F0KFtcclxuICAgICAgICAgICAgQnVmZmVyLmFsbG9jKDQgLSBhbGdvcml0aG0ucHVibGljRXhwb25lbnQuYnl0ZUxlbmd0aCwgMCksXHJcbiAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCksXHJcbiAgICAgICAgXSkucmVhZEludDMyQkUoMCk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGNyeXB0by5nZW5lcmF0ZUtleVBhaXJTeW5jKFwicnNhXCIsIHtcclxuICAgICAgICAgICAgbW9kdWx1c0xlbmd0aDogYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGgsXHJcbiAgICAgICAgICAgIHB1YmxpY0V4cG9uZW50LFxyXG4gICAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzcGtpXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJwa2NzOFwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHByaXZhdGVLZXkuZGF0YSA9IGtleXMucHJpdmF0ZUtleTtcclxuICAgICAgICBwdWJsaWNLZXkuZGF0YSA9IGtleXMucHVibGljS2V5O1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleSxcclxuICAgICAgICAgICAgcHVibGljS2V5LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBleHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpO1xyXG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjpcclxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShrZXkuZGF0YSkuYnVmZmVyO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJywgJ3BrY3M4JyBvciAnc3BraSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBqd2sgPSBrZXlEYXRhO1xyXG4gICAgICAgICAgICAgICAgaWYgKGp3ay5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQcml2YXRlS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQdWJsaWNLZXkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5SW5mby5wdWJsaWNLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLlJzYVB1YmxpY0tleSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJwa2NzOFwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHJpdmF0ZUtleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUnNhUHJpdmF0ZUtleSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJywgJ3BrY3M4JyBvciAnc3BraSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIHNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlJTQS1QU1NcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlJTQVNTQS1QS0NTMS1WMV81XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduUnNhKGFsZ29yaXRobSwga2V5LCBkYXRhKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyB2ZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiUlNBLVBTU1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiUlNBU1NBLVBLQ1MxLVYxXzVcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeVNTQShhbGdvcml0aG0sIGtleSwgZGF0YSwgc2lnbmF0dXJlKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJSU0EtT0FFUFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdE9BRVAoYWxnb3JpdGhtLCBrZXksIGRhdGEpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlJTQS1PQUVQXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0T0FFUChhbGdvcml0aG0sIGtleSwgZGF0YSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjExMzU0OS4xLjEuMVwiO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gbnVsbDtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXkgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGFzbktleSk7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IFJzYVByaXZhdGVLZXkoKTtcclxuICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0ucHVibGljRXhwb25lbnQgPSBuZXcgVWludDhBcnJheShhc25LZXkucHVibGljRXhwb25lbnQpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA9IGFzbktleS5tb2R1bHVzLmJ5dGVMZW5ndGggPDwgMztcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjExMzU0OS4xLjEuMVwiO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMgPSBudWxsO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShhc25LZXkpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBSc2FQdWJsaWNLZXkoKTtcclxuICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0ucHVibGljRXhwb25lbnQgPSBuZXcgVWludDhBcnJheShhc25LZXkucHVibGljRXhwb25lbnQpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA9IGFzbktleS5tb2R1bHVzLmJ5dGVMZW5ndGggPDwgMztcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0Q3J5cHRvQWxnb3JpdGhtKGFsZykge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnLmhhc2gubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUlNBLVNIQTFcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0yNTZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlJTQS1TSEEyNTZcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0zODRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlJTQS1TSEEzODRcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS01MTJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlJTQS1TSEE1MTJcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMy0yNTZcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMzg0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMy0zODRcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtNTEyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMy01MTJcIjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG0uaGFzaDogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIHNpZ25Sc2EoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSB0aGlzLmdldENyeXB0b0FsZ29yaXRobShrZXkuYWxnb3JpdGhtKTtcclxuICAgICAgICBjb25zdCBzaWduZXIgPSBjcnlwdG8uY3JlYXRlU2lnbihjcnlwdG9BbGcpO1xyXG4gICAgICAgIHNpZ25lci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgIGlmICgha2V5LnBlbSkge1xyXG4gICAgICAgICAgICBrZXkucGVtID0gYC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleToga2V5LnBlbSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIlJTQS1QU1NcIikge1xyXG4gICAgICAgICAgICBvcHRpb25zLnBhZGRpbmcgPSBjcnlwdG8uY29uc3RhbnRzLlJTQV9QS0NTMV9QU1NfUEFERElORztcclxuICAgICAgICAgICAgb3B0aW9ucy5zYWx0TGVuZ3RoID0gYWxnb3JpdGhtLnNhbHRMZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25lci5zaWduKG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShzaWduYXR1cmUpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyB2ZXJpZnlTU0EoYWxnb3JpdGhtLCBrZXksIGRhdGEsIHNpZ25hdHVyZSkge1xyXG4gICAgICAgIGNvbnN0IGNyeXB0b0FsZyA9IHRoaXMuZ2V0Q3J5cHRvQWxnb3JpdGhtKGtleS5hbGdvcml0aG0pO1xyXG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGNyeXB0by5jcmVhdGVWZXJpZnkoY3J5cHRvQWxnKTtcclxuICAgICAgICBzaWduZXIudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICBpZiAoIWtleS5wZW0pIHtcclxuICAgICAgICAgICAga2V5LnBlbSA9IGAtLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBrZXkucGVtLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiUlNBLVBTU1wiKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMucGFkZGluZyA9IGNyeXB0by5jb25zdGFudHMuUlNBX1BLQ1MxX1BTU19QQURESU5HO1xyXG4gICAgICAgICAgICBvcHRpb25zLnNhbHRMZW5ndGggPSBhbGdvcml0aG0uc2FsdExlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb2sgPSBzaWduZXIudmVyaWZ5KG9wdGlvbnMsIHNpZ25hdHVyZSk7XHJcbiAgICAgICAgcmV0dXJuIG9rO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGVuY3J5cHRPQUVQKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBgLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLWAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IGNyeXB0by5jb25zdGFudHMuUlNBX1BLQ1MxX09BRVBfUEFERElORyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChhbGdvcml0aG0ubGFiZWwpIDtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvLnB1YmxpY0VuY3J5cHQob3B0aW9ucywgZGF0YSkpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZWNyeXB0T0FFUChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleTogYC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLWAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IGNyeXB0by5jb25zdGFudHMuUlNBX1BLQ1MxX09BRVBfUEFERElORyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChhbGdvcml0aG0ubGFiZWwpIDtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvLnByaXZhdGVEZWNyeXB0KG9wdGlvbnMsIGRhdGEpKS5idWZmZXI7XHJcbiAgICB9XHJcbn1cclxuUnNhQ3J5cHRvLnB1YmxpY0tleVVzYWdlcyA9IFtcInZlcmlmeVwiLCBcImVuY3J5cHRcIiwgXCJ3cmFwS2V5XCJdO1xyXG5Sc2FDcnlwdG8ucHJpdmF0ZUtleVVzYWdlcyA9IFtcInNpZ25cIiwgXCJkZWNyeXB0XCIsIFwidW53cmFwS2V5XCJdO1xuXG5jbGFzcyBSc2FTc2FQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Sc2FTc2FQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXHJcbiAgICAgICAgICAgIFwiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIixcclxuICAgICAgICAgICAgXCJzaGFrZTEyOFwiLCBcInNoYWtlMjU2XCIsXHJcbiAgICAgICAgICAgIFwiU0hBMy0yNTZcIiwgXCJTSEEzLTM4NFwiLCBcIlNIQTMtNTEyXCJcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgUnNhQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgLi4uYWxnb3JpdGhtLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by5zaWduKGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uVmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLnZlcmlmeShhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShzaWduYXR1cmUpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBSc2FDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBSU0EgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBSc2FQc3NQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Sc2FQc3NQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXHJcbiAgICAgICAgICAgIFwiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIixcclxuICAgICAgICAgICAgXCJzaGFrZTEyOFwiLCBcInNoYWtlMjU2XCIsXHJcbiAgICAgICAgICAgIFwiU0hBMy0yNTZcIiwgXCJTSEEzLTM4NFwiLCBcIlNIQTMtNTEyXCJcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgUnNhQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgLi4uYWxnb3JpdGhtLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by5zaWduKGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uVmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLnZlcmlmeShhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShzaWduYXR1cmUpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBSc2FDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBSU0EgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGFDcnlwdG8ge1xyXG4gICAgc3RhdGljIHNpemUoYWxnb3JpdGhtKSB7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE2MDtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0yNTZcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMjU2O1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTM4NFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiU0hBMy0zODRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAzODQ7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtNTEyXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTUxMlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDUxMjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBuYW1lXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRBbGdvcml0aG1OYW1lKGFsZ29yaXRobSkge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTFcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTFcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0yNTZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTI1NlwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTM4NFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhMzg0XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtNTEyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGE1MTJcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGEzLTI1NlwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBMy0zODRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTMtMzg0XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTUxMlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhMy01MTJcIjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBuYW1lXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBkaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgaGFzaEFsZyA9IHRoaXMuZ2V0QWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChoYXNoQWxnKVxyXG4gICAgICAgICAgICAudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKS5kaWdlc3QoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGFzaCkuYnVmZmVyO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFJzYU9hZXBQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Sc2FPYWVwUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgUnNhQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgLi4uYWxnb3JpdGhtLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xyXG4gICAgICAgIGNvbnN0IGtleVNpemUgPSBNYXRoLmNlaWwoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggPj4gMyk7XHJcbiAgICAgICAgY29uc3QgaGFzaFNpemUgPSBTaGFDcnlwdG8uc2l6ZShpbnRlcm5hbEtleS5hbGdvcml0aG0uaGFzaCkgPj4gMztcclxuICAgICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGF0YVZpZXcuYnl0ZUxlbmd0aDtcclxuICAgICAgICBjb25zdCBwc0xlbmd0aCA9IGtleVNpemUgLSBkYXRhTGVuZ3RoIC0gMiAqIGhhc2hTaXplIC0gMjtcclxuICAgICAgICBpZiAoZGF0YUxlbmd0aCA+IGtleVNpemUgLSAyICogaGFzaFNpemUgLSAyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgdG9vIGxhcmdlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkoa2V5U2l6ZSk7XHJcbiAgICAgICAgY29uc3Qgc2VlZCA9IG1lc3NhZ2Uuc3ViYXJyYXkoMSwgaGFzaFNpemUgKyAxKTtcclxuICAgICAgICBjb25zdCBkYXRhQmxvY2sgPSBtZXNzYWdlLnN1YmFycmF5KGhhc2hTaXplICsgMSk7XHJcbiAgICAgICAgZGF0YUJsb2NrLnNldChkYXRhVmlldywgaGFzaFNpemUgKyBwc0xlbmd0aCArIDEpO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsSGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLm5hbWUucmVwbGFjZShcIi1cIiwgXCJcIikpXHJcbiAgICAgICAgICAgIC51cGRhdGUoY29yZV9fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoYWxnb3JpdGhtLmxhYmVsIHx8IG5ldyBVaW50OEFycmF5KDApKSlcclxuICAgICAgICAgICAgLmRpZ2VzdCgpO1xyXG4gICAgICAgIGRhdGFCbG9jay5zZXQobGFiZWxIYXNoLCAwKTtcclxuICAgICAgICBkYXRhQmxvY2tbaGFzaFNpemUgKyBwc0xlbmd0aF0gPSAxO1xyXG4gICAgICAgIGNyeXB0by5yYW5kb21GaWxsU3luYyhzZWVkKTtcclxuICAgICAgICBjb25zdCBkYXRhQmxvY2tNYXNrID0gdGhpcy5tZ2YxKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLCBzZWVkLCBkYXRhQmxvY2subGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFCbG9jay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkYXRhQmxvY2tbaV0gXj0gZGF0YUJsb2NrTWFza1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VlZE1hc2sgPSB0aGlzLm1nZjEoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gsIGRhdGFCbG9jaywgc2VlZC5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWVkW2ldIF49IHNlZWRNYXNrW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWludGVybmFsS2V5LnBlbSkge1xyXG4gICAgICAgICAgICBpbnRlcm5hbEtleS5wZW0gPSBgLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG4ke2ludGVybmFsS2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGtjczAgPSBjcnlwdG8ucHVibGljRW5jcnlwdCh7XHJcbiAgICAgICAgICAgIGtleTogaW50ZXJuYWxLZXkucGVtLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9OT19QQURESU5HLFxyXG4gICAgICAgIH0sIEJ1ZmZlci5mcm9tKG1lc3NhZ2UpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocGtjczApLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgY29uc3Qga2V5U2l6ZSA9IE1hdGguY2VpbChpbnRlcm5hbEtleS5hbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA+PiAzKTtcclxuICAgICAgICBjb25zdCBoYXNoU2l6ZSA9IFNoYUNyeXB0by5zaXplKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoKSA+PiAzO1xyXG4gICAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgaWYgKGRhdGFMZW5ndGggIT09IGtleVNpemUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIGRhdGFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaW50ZXJuYWxLZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGludGVybmFsS2V5LnBlbSA9IGAtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cXG4ke2ludGVybmFsS2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwa2NzMCA9IGNyeXB0by5wcml2YXRlRGVjcnlwdCh7XHJcbiAgICAgICAgICAgIGtleTogaW50ZXJuYWxLZXkucGVtLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9OT19QQURESU5HLFxyXG4gICAgICAgIH0sIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICBjb25zdCB6ID0gcGtjczBbMF07XHJcbiAgICAgICAgY29uc3Qgc2VlZCA9IHBrY3MwLnN1YmFycmF5KDEsIGhhc2hTaXplICsgMSk7XHJcbiAgICAgICAgY29uc3QgZGF0YUJsb2NrID0gcGtjczAuc3ViYXJyYXkoaGFzaFNpemUgKyAxKTtcclxuICAgICAgICBpZiAoeiAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWNyeXB0aW9uIGZhaWxlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VlZE1hc2sgPSB0aGlzLm1nZjEoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gsIGRhdGFCbG9jaywgc2VlZC5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWVkW2ldIF49IHNlZWRNYXNrW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhQmxvY2tNYXNrID0gdGhpcy5tZ2YxKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLCBzZWVkLCBkYXRhQmxvY2subGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFCbG9jay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkYXRhQmxvY2tbaV0gXj0gZGF0YUJsb2NrTWFza1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGFiZWxIYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gubmFtZS5yZXBsYWNlKFwiLVwiLCBcIlwiKSlcclxuICAgICAgICAgICAgLnVwZGF0ZShjb3JlX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShhbGdvcml0aG0ubGFiZWwgfHwgbmV3IFVpbnQ4QXJyYXkoMCkpKVxyXG4gICAgICAgICAgICAuZGlnZXN0KCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYXNoU2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsYWJlbEhhc2hbaV0gIT09IGRhdGFCbG9ja1tpXSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjcnlwdGlvbiBmYWlsZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHBzRW5kID0gaGFzaFNpemU7XHJcbiAgICAgICAgZm9yICg7IHBzRW5kIDwgZGF0YUJsb2NrLmxlbmd0aDsgcHNFbmQrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwc3ogPSBkYXRhQmxvY2tbcHNFbmRdO1xyXG4gICAgICAgICAgICBpZiAocHN6ID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHN6ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWNyeXB0aW9uIGZhaWxlZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHNFbmQgPT09IGRhdGFCbG9jay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjcnlwdGlvbiBmYWlsZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBrY3MwID0gZGF0YUJsb2NrLnN1YmFycmF5KHBzRW5kICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHBrY3MwKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBSc2FDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBSU0EgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1nZjEoYWxnb3JpdGhtLCBzZWVkLCBsZW5ndGggPSAwKSB7XHJcbiAgICAgICAgY29uc3QgaGFzaFNpemUgPSBTaGFDcnlwdG8uc2l6ZShhbGdvcml0aG0pID4+IDM7XHJcbiAgICAgICAgY29uc3QgbWFzayA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBVaW50OEFycmF5KDQpO1xyXG4gICAgICAgIGNvbnN0IGNodW5rcyA9IE1hdGguY2VpbChsZW5ndGggLyBoYXNoU2l6ZSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3M7IGkrKykge1xyXG4gICAgICAgICAgICBjb3VudGVyWzBdID0gaSA+Pj4gMjQ7XHJcbiAgICAgICAgICAgIGNvdW50ZXJbMV0gPSAoaSA+Pj4gMTYpICYgMjU1O1xyXG4gICAgICAgICAgICBjb3VudGVyWzJdID0gKGkgPj4+IDgpICYgMjU1O1xyXG4gICAgICAgICAgICBjb3VudGVyWzNdID0gaSAmIDI1NTtcclxuICAgICAgICAgICAgY29uc3Qgc3VibWFzayA9IG1hc2suc3ViYXJyYXkoaSAqIGhhc2hTaXplKTtcclxuICAgICAgICAgICAgbGV0IGNodW5rID0gY3J5cHRvLmNyZWF0ZUhhc2goYWxnb3JpdGhtLm5hbWUucmVwbGFjZShcIi1cIiwgXCJcIikpXHJcbiAgICAgICAgICAgICAgICAudXBkYXRlKHNlZWQpXHJcbiAgICAgICAgICAgICAgICAudXBkYXRlKGNvdW50ZXIpXHJcbiAgICAgICAgICAgICAgICAuZGlnZXN0KCk7XHJcbiAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGggPiBzdWJtYXNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5zdWJhcnJheSgwLCBzdWJtYXNrLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3VibWFzay5zZXQoY2h1bmspO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWFzaztcclxuICAgIH1cclxufVxuXG5jbGFzcyBSc2FFc1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlByb3ZpZGVyQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJSU0FFUy1QS0NTMS12MV81XCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSB7XHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogW1wiZW5jcnlwdFwiLCBcIndyYXBLZXlcIl0sXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IFtcImRlY3J5cHRcIiwgXCJ1bndyYXBLZXlcIl0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IFJzYUNyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcInB1YmxpY0V4cG9uZW50XCIpO1xyXG4gICAgICAgIGlmICghKGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCAmJiBhbGdvcml0aG0ucHVibGljRXhwb25lbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicHVibGljRXhwb25lbnQ6IE1pc3Npbmcgb3Igbm90IGEgVWludDhBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHVibGljRXhwb25lbnQgPSBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NChhbGdvcml0aG0ucHVibGljRXhwb25lbnQpO1xyXG4gICAgICAgIGlmICghKHB1YmxpY0V4cG9uZW50ID09PSBcIkF3PT1cIiB8fCBwdWJsaWNFeHBvbmVudCA9PT0gXCJBUUFCXCIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwdWJsaWNFeHBvbmVudDogTXVzdCBiZSBbM10gb3IgWzEsMCwxXVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcIm1vZHVsdXNMZW5ndGhcIik7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubW9kdWx1c0xlbmd0aCkge1xyXG4gICAgICAgICAgICBjYXNlIDEwMjQ6XHJcbiAgICAgICAgICAgIGNhc2UgMjA0ODpcclxuICAgICAgICAgICAgY2FzZSA0MDk2OlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibW9kdWx1c0xlbmd0aDogTXVzdCBiZSAxMDI0LCAyMDQ4LCBvciA0MDk2XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnRvQ3J5cHRvT3B0aW9ucyhrZXkpO1xyXG4gICAgICAgIGNvbnN0IGVuYyA9IGNyeXB0b19fbmFtZXNwYWNlLnB1YmxpY0VuY3J5cHQob3B0aW9ucywgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnRvQ3J5cHRvT3B0aW9ucyhrZXkpO1xyXG4gICAgICAgIGNvbnN0IGRlYyA9IGNyeXB0b19fbmFtZXNwYWNlLnByaXZhdGVEZWNyeXB0KG9wdGlvbnMsIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBSc2FDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBSU0EgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvQ3J5cHRvT3B0aW9ucyhrZXkpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0ga2V5LnR5cGUudG9VcHBlckNhc2UoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBrZXk6IGAtLS0tLUJFR0lOICR7dHlwZX0gS0VZLS0tLS1cXG4ke2dldENyeXB0b0tleShrZXkpLmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgJHt0eXBlfSBLRVktLS0tLWAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IGNyeXB0b19fbmFtZXNwYWNlLmNvbnN0YW50cy5SU0FfUEtDUzFfUEFERElORyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IG5hbWVkT0lEcyA9IHtcclxuICAgIFwiMS4yLjg0MC4xMDA0NS4zLjEuN1wiOiBcIlAtMjU2XCIsXHJcbiAgICBcIlAtMjU2XCI6IFwiMS4yLjg0MC4xMDA0NS4zLjEuN1wiLFxyXG4gICAgXCIxLjMuMTMyLjAuMzRcIjogXCJQLTM4NFwiLFxyXG4gICAgXCJQLTM4NFwiOiBcIjEuMy4xMzIuMC4zNFwiLFxyXG4gICAgXCIxLjMuMTMyLjAuMzVcIjogXCJQLTUyMVwiLFxyXG4gICAgXCJQLTUyMVwiOiBcIjEuMy4xMzIuMC4zNVwiLFxyXG4gICAgXCIxLjMuMTMyLjAuMTBcIjogXCJLLTI1NlwiLFxyXG4gICAgXCJLLTI1NlwiOiBcIjEuMy4xMzIuMC4xMFwiLFxyXG4gICAgXCJicmFpbnBvb2xQMTYwcjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMVwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMVwiOiBcImJyYWlucG9vbFAxNjByMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMTYwdDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMlwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMlwiOiBcImJyYWlucG9vbFAxNjB0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMTkycjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuM1wiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuM1wiOiBcImJyYWlucG9vbFAxOTJyMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMTkydDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuNFwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuNFwiOiBcImJyYWlucG9vbFAxOTJ0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMjI0cjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuNVwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuNVwiOiBcImJyYWlucG9vbFAyMjRyMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMjI0dDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuNlwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuNlwiOiBcImJyYWlucG9vbFAyMjR0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMjU2cjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuN1wiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuN1wiOiBcImJyYWlucG9vbFAyNTZyMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMjU2dDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuOFwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuOFwiOiBcImJyYWlucG9vbFAyNTZ0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMzIwcjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuOVwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuOVwiOiBcImJyYWlucG9vbFAzMjByMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMzIwdDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTBcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjEwXCI6IFwiYnJhaW5wb29sUDMyMHQxXCIsXHJcbiAgICBcImJyYWlucG9vbFAzODRyMVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS4xMVwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTFcIjogXCJicmFpbnBvb2xQMzg0cjFcIixcclxuICAgIFwiYnJhaW5wb29sUDM4NHQxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjEyXCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS4xMlwiOiBcImJyYWlucG9vbFAzODR0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQNTEycjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTNcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjEzXCI6IFwiYnJhaW5wb29sUDUxMnIxXCIsXHJcbiAgICBcImJyYWlucG9vbFA1MTJ0MVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS4xNFwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTRcIjogXCJicmFpbnBvb2xQNTEydDFcIixcclxufTtcclxuZnVuY3Rpb24gZ2V0T2lkQnlOYW1lZEN1cnZlJDEobmFtZWRDdXJ2ZSkge1xyXG4gICAgY29uc3Qgb2lkID0gbmFtZWRPSURzW25hbWVkQ3VydmVdO1xyXG4gICAgaWYgKCFvaWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgY29udmVydCBXZWJDcnlwdG8gbmFtZWQgY3VydmUgJyR7bmFtZWRDdXJ2ZX0nIHRvIE9JRGApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9pZDtcclxufVxuXG5jbGFzcyBFY1ByaXZhdGVLZXkgZXh0ZW5kcyBBc3ltbWV0cmljS2V5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJwcml2YXRlXCI7XHJcbiAgICB9XHJcbiAgICBnZXRLZXkoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8pO1xyXG4gICAgICAgIHJldHVybiBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXlJbmZvLnByaXZhdGVLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHJpdmF0ZUtleSk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcclxuICAgICAgICBjb25zdCBqc29uID0ge1xyXG4gICAgICAgICAgICBrdHk6IFwiRUNcIixcclxuICAgICAgICAgICAgY3J2OiB0aGlzLmFsZ29yaXRobS5uYW1lZEN1cnZlLFxyXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcclxuICAgICAgICAgICAgZXh0OiB0aGlzLmV4dHJhY3RhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oanNvbiwganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KSk7XHJcbiAgICB9XHJcbiAgICBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgaWYgKCFqc29uLmNydikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgZ2V0IG5hbWVkIGN1cnZlIGZyb20gSldLLiBQcm9wZXJ0eSAnY3J2JyBpcyByZXF1aXJlZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMDA0NS4yLjFcIjtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUobmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLk9iamVjdElkZW50aWZpZXIoZ2V0T2lkQnlOYW1lZEN1cnZlJDEoanNvbi5jcnYpKSk7XHJcbiAgICAgICAgY29uc3Qga2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGpzb24sIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1ByaXZhdGVLZXkgfSk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXkpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEVjUHVibGljS2V5IGV4dGVuZHMgQXN5bW1ldHJpY0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicHVibGljXCI7XHJcbiAgICB9XHJcbiAgICBnZXRLZXkoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1B1YmxpY0tleShrZXlJbmZvLnB1YmxpY0tleSk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcclxuICAgICAgICBjb25zdCBqc29uID0ge1xyXG4gICAgICAgICAgICBrdHk6IFwiRUNcIixcclxuICAgICAgICAgICAgY3J2OiB0aGlzLmFsZ29yaXRobS5uYW1lZEN1cnZlLFxyXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcclxuICAgICAgICAgICAgZXh0OiB0aGlzLmV4dHJhY3RhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oanNvbiwganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KSk7XHJcbiAgICB9XHJcbiAgICBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgaWYgKCFqc29uLmNydikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgZ2V0IG5hbWVkIGN1cnZlIGZyb20gSldLLiBQcm9wZXJ0eSAnY3J2JyBpcyByZXF1aXJlZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oanNvbiwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHVibGljS2V5IH0pO1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMDA0NS4yLjFcIjtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuT2JqZWN0SWRlbnRpZmllcihnZXRPaWRCeU5hbWVkQ3VydmUkMShqc29uLmNydikpKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleSA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci50b0FTTihrZXkpLnZhbHVlSGV4O1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYTFQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBLTFcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGEyNTZQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBLTI1NlwiO1xyXG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hhQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYTM4NFByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlByb3ZpZGVyQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTSEEtMzg0XCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hhNTEyUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUHJvdmlkZXJDcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQS01MTJcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGEzMjU2UHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUHJvdmlkZXJDcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQTMtMjU2XCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hhMzM4NFByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlByb3ZpZGVyQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTSEEzLTM4NFwiO1xyXG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hhQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYTM1MTJQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBMy01MTJcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBFY0NyeXB0byB7XHJcbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IG5ldyBFY1ByaXZhdGVLZXkoKTtcclxuICAgICAgICBwcml2YXRlS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBwcml2YXRlS2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAgcHJpdmF0ZUtleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wcml2YXRlS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XHJcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IEVjUHVibGljS2V5KCk7XHJcbiAgICAgICAgcHVibGljS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBwdWJsaWNLZXkuZXh0cmFjdGFibGUgPSB0cnVlO1xyXG4gICAgICAgIHB1YmxpY0tleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wdWJsaWNLZXlVc2FnZXMuaW5kZXhPZih1c2FnZSkgIT09IC0xKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gY3J5cHRvLmdlbmVyYXRlS2V5UGFpclN5bmMoXCJlY1wiLCB7XHJcbiAgICAgICAgICAgIG5hbWVkQ3VydmU6IHRoaXMuZ2V0T3BlblNTTE5hbWVkQ3VydmUoYWxnb3JpdGhtLm5hbWVkQ3VydmUpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzcGtpXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJwa2NzOFwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHByaXZhdGVLZXkuZGF0YSA9IGtleXMucHJpdmF0ZUtleTtcclxuICAgICAgICBwdWJsaWNLZXkuZGF0YSA9IGtleXMucHVibGljS2V5O1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleSxcclxuICAgICAgICAgICAgcHVibGljS2V5LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBzaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gU2hhQ3J5cHRvLmdldEFsZ29yaXRobU5hbWUoYWxnb3JpdGhtLmhhc2gpO1xyXG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGNyeXB0by5jcmVhdGVTaWduKGNyeXB0b0FsZyk7XHJcbiAgICAgICAgc2lnbmVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgaWYgKCFrZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBrZXkucGVtLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmVyLnNpZ24ob3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgZWNTaWduYXR1cmUgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShzaWduYXR1cmUsIGNvcmVfX25hbWVzcGFjZS5hc24xLkVjRHNhU2lnbmF0dXJlKTtcclxuICAgICAgICBjb25zdCBzaWduYXR1cmVSYXcgPSBjb3JlX19uYW1lc3BhY2UuRWNVdGlscy5lbmNvZGVTaWduYXR1cmUoZWNTaWduYXR1cmUsIGNvcmVfX25hbWVzcGFjZS5FY0N1cnZlcy5nZXQoa2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlKS5zaXplKTtcclxuICAgICAgICByZXR1cm4gc2lnbmF0dXJlUmF3LmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyB2ZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNyeXB0b0FsZyA9IFNoYUNyeXB0by5nZXRBbGdvcml0aG1OYW1lKGFsZ29yaXRobS5oYXNoKTtcclxuICAgICAgICBjb25zdCBzaWduZXIgPSBjcnlwdG8uY3JlYXRlVmVyaWZ5KGNyeXB0b0FsZyk7XHJcbiAgICAgICAgc2lnbmVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgaWYgKCFrZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleToga2V5LnBlbSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGVjU2lnbmF0dXJlID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjRHNhU2lnbmF0dXJlKCk7XHJcbiAgICAgICAgY29uc3QgbmFtZWRDdXJ2ZSA9IGNvcmVfX25hbWVzcGFjZS5FY0N1cnZlcy5nZXQoa2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlKTtcclxuICAgICAgICBjb25zdCBzaWduYXR1cmVQb2ludCA9IGNvcmVfX25hbWVzcGFjZS5FY1V0aWxzLmRlY29kZVNpZ25hdHVyZShzaWduYXR1cmUsIG5hbWVkQ3VydmUuc2l6ZSk7XHJcbiAgICAgICAgZWNTaWduYXR1cmUuciA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihzaWduYXR1cmVQb2ludC5yKTtcclxuICAgICAgICBlY1NpZ25hdHVyZS5zID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHNpZ25hdHVyZVBvaW50LnMpO1xyXG4gICAgICAgIGNvbnN0IGVjU2lnbmF0dXJlUmF3ID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShlY1NpZ25hdHVyZSkpO1xyXG4gICAgICAgIGNvbnN0IG9rID0gc2lnbmVyLnZlcmlmeShvcHRpb25zLCBlY1NpZ25hdHVyZVJhdyk7XHJcbiAgICAgICAgcmV0dXJuIG9rO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSB0aGlzLmdldE9wZW5TU0xOYW1lZEN1cnZlKGJhc2VLZXkuYWxnb3JpdGhtLm5hbWVkQ3VydmUpO1xyXG4gICAgICAgIGNvbnN0IGVjZGggPSBjcnlwdG8uY3JlYXRlRUNESChjcnlwdG9BbGcpO1xyXG4gICAgICAgIGNvbnN0IGFzblByaXZhdGVLZXkgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShiYXNlS2V5LmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICBjb25zdCBhc25FY1ByaXZhdGVLZXkgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShhc25Qcml2YXRlS2V5LnByaXZhdGVLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHJpdmF0ZUtleSk7XHJcbiAgICAgICAgZWNkaC5zZXRQcml2YXRlS2V5KEJ1ZmZlci5mcm9tKGFzbkVjUHJpdmF0ZUtleS5wcml2YXRlS2V5KSk7XHJcbiAgICAgICAgY29uc3QgYXNuUHVibGljS2V5ID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UoYWxnb3JpdGhtLnB1YmxpYy5kYXRhLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKTtcclxuICAgICAgICBjb25zdCBiaXRzID0gZWNkaC5jb21wdXRlU2VjcmV0KEJ1ZmZlci5mcm9tKGFzblB1YmxpY0tleS5wdWJsaWNLZXkpKTtcclxuICAgICAgICBpZiAobGVuZ3RoID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYml0cykuYnVmZmVyLnNsaWNlKDAsIGxlbmd0aCA+PiAzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBleHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpO1xyXG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjpcclxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShrZXkuZGF0YSkuYnVmZmVyO1xyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXkuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHVibGljS2V5SW5mby5wdWJsaWNLZXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycsICdyYXcnLCBwa2NzOCcgb3IgJ3Nwa2knXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgandrID0ga2V5RGF0YTtcclxuICAgICAgICAgICAgICAgIGlmIChqd2suZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQcml2YXRlS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1B1YmxpY0tleSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHVibGljS2V5KGtleURhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHVibGljS2V5KGtleUluZm8ucHVibGljS2V5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0S2V5UGFyYW1ldGVycyhrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5wYXJhbWV0ZXJzLCBhbGdvcml0aG0ubmFtZWRDdXJ2ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJwa2NzOFwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHJpdmF0ZUtleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQcml2YXRlS2V5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0S2V5UGFyYW1ldGVycyhrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0ucGFyYW1ldGVycywgYWxnb3JpdGhtLm5hbWVkQ3VydmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycsICdyYXcnLCAncGtjczgnIG9yICdzcGtpJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXNzZXJ0S2V5UGFyYW1ldGVycyhwYXJhbWV0ZXJzLCBuYW1lZEN1cnZlKSB7XHJcbiAgICAgICAgaWYgKCFwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuQ3J5cHRvRXJyb3IoXCJLZXkgaW5mbyBkb2Vzbid0IGhhdmUgcmVxdWlyZWQgcGFyYW1ldGVyc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5hbWVkQ3VydmVJZGVudGlmaWVyID0gXCJcIjtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBuYW1lZEN1cnZlSWRlbnRpZmllciA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHBhcmFtZXRlcnMsIGNvcmVfX25hbWVzcGFjZS5hc24xLk9iamVjdElkZW50aWZpZXIpLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLkNyeXB0b0Vycm9yKFwiQ2Fubm90IHJlYWQga2V5IGluZm8gcGFyYW1ldGVyc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdldE9pZEJ5TmFtZWRDdXJ2ZSQxKG5hbWVkQ3VydmUpICE9PSBuYW1lZEN1cnZlSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLkNyeXB0b0Vycm9yKFwiS2V5IGluZm8gcGFyYW1ldGVyIGRvZXNuJ3QgbWF0Y2ggdG8gbmFtZWQgY3VydmVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMDA0NS4yLjFcIjtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUobmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLk9iamVjdElkZW50aWZpZXIoZ2V0T2lkQnlOYW1lZEN1cnZlJDEoYWxnb3JpdGhtLm5hbWVkQ3VydmUpKSk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShhc25LZXkpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBFY1ByaXZhdGVLZXkoKTtcclxuICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5hbGdvcml0aG0gPSBcIjEuMi44NDAuMTAwNDUuMi4xXCI7XHJcbiAgICAgICAgY29uc3QgbmFtZWRDdXJ2ZSA9IGdldE9pZEJ5TmFtZWRDdXJ2ZSQxKGFsZ29yaXRobS5uYW1lZEN1cnZlKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuT2JqZWN0SWRlbnRpZmllcihuYW1lZEN1cnZlKSk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXkgPSBhc25LZXkudmFsdWU7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEVjUHVibGljS2V5KCk7XHJcbiAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gT2JqZWN0LmFzc2lnbih7fSwgYWxnb3JpdGhtKTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0T3BlblNTTE5hbWVkQ3VydmUoY3VydmUpIHtcclxuICAgICAgICBzd2l0Y2ggKGN1cnZlLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlAtMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJwcmltZTI1NnYxXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJLLTI1NlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2VjcDI1NmsxXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJQLTM4NFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2VjcDM4NHIxXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJQLTUyMVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2VjcDUyMXIxXCI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VydmU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkVjQ3J5cHRvLnB1YmxpY0tleVVzYWdlcyA9IFtcInZlcmlmeVwiXTtcclxuRWNDcnlwdG8ucHJpdmF0ZUtleVVzYWdlcyA9IFtcInNpZ25cIiwgXCJkZXJpdmVLZXlcIiwgXCJkZXJpdmVCaXRzXCJdO1xuXG5jbGFzcyBFY2RzYVByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkVjZHNhUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWVkQ3VydmVzID0gY29yZV9fbmFtZXNwYWNlLkVjQ3VydmVzLm5hbWVzO1xyXG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXHJcbiAgICAgICAgICAgIFwiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIixcclxuICAgICAgICAgICAgXCJzaGFrZTEyOFwiLCBcInNoYWtlMjU2XCIsXHJcbiAgICAgICAgICAgIFwiU0hBMy0yNTZcIiwgXCJTSEEzLTM4NFwiLCBcIlNIQTMtNTEyXCJcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgRWNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICAuLi5hbGdvcml0aG0sXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcclxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gRWNDcnlwdG8uc2lnbihhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEVjQ3J5cHRvLnZlcmlmeShhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShzaWduYXR1cmUpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBFY0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEVjQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgaWYgKCEoaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBFY1ByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBFY1B1YmxpY0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IEVDIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRWNkaFByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkVjZGhQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZWRDdXJ2ZXMgPSBjb3JlX19uYW1lc3BhY2UuRWNDdXJ2ZXMubmFtZXM7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBFY0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEVjQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRWNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIEVjUHJpdmF0ZUtleSB8fCBpbnRlcm5hbEtleSBpbnN0YW5jZW9mIEVjUHVibGljS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgRUMgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVyaXZlQml0cyhhbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGJpdHMgPSBhd2FpdCBFY0NyeXB0by5kZXJpdmVCaXRzKHsgLi4uYWxnb3JpdGhtLCBwdWJsaWM6IGdldENyeXB0b0tleShhbGdvcml0aG0ucHVibGljKSB9LCBnZXRDcnlwdG9LZXkoYmFzZUtleSksIGxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgZWRPSURzID0ge1xyXG4gICAgW2NvcmVfX25hbWVzcGFjZS5hc24xLmlkRWQ0NDhdOiBcIkVkNDQ4XCIsXHJcbiAgICBcImVkNDQ4XCI6IGNvcmVfX25hbWVzcGFjZS5hc24xLmlkRWQ0NDgsXHJcbiAgICBbY29yZV9fbmFtZXNwYWNlLmFzbjEuaWRYNDQ4XTogXCJYNDQ4XCIsXHJcbiAgICBcIng0NDhcIjogY29yZV9fbmFtZXNwYWNlLmFzbjEuaWRYNDQ4LFxyXG4gICAgW2NvcmVfX25hbWVzcGFjZS5hc24xLmlkRWQyNTUxOV06IFwiRWQyNTUxOVwiLFxyXG4gICAgXCJlZDI1NTE5XCI6IGNvcmVfX25hbWVzcGFjZS5hc24xLmlkRWQyNTUxOSxcclxuICAgIFtjb3JlX19uYW1lc3BhY2UuYXNuMS5pZFgyNTUxOV06IFwiWDI1NTE5XCIsXHJcbiAgICBcIngyNTUxOVwiOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5pZFgyNTUxOSxcclxufTtcclxuZnVuY3Rpb24gZ2V0T2lkQnlOYW1lZEN1cnZlKG5hbWVkQ3VydmUpIHtcclxuICAgIGNvbnN0IG9pZCA9IGVkT0lEc1tuYW1lZEN1cnZlLnRvTG93ZXJDYXNlKCldO1xyXG4gICAgaWYgKCFvaWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgY29udmVydCBXZWJDcnlwdG8gbmFtZWQgY3VydmUgJyR7bmFtZWRDdXJ2ZX0nIHRvIE9JRGApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9pZDtcclxufVxuXG5jbGFzcyBFZFByaXZhdGVLZXkgZXh0ZW5kcyBBc3ltbWV0cmljS2V5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJwcml2YXRlXCI7XHJcbiAgICB9XHJcbiAgICBnZXRLZXkoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8pO1xyXG4gICAgICAgIHJldHVybiBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXlJbmZvLnByaXZhdGVLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLkN1cnZlUHJpdmF0ZUtleSk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcclxuICAgICAgICBjb25zdCBqc29uID0ge1xyXG4gICAgICAgICAgICBrdHk6IFwiT0tQXCIsXHJcbiAgICAgICAgICAgIGNydjogdGhpcy5hbGdvcml0aG0ubmFtZWRDdXJ2ZSxcclxuICAgICAgICAgICAga2V5X29wczogdGhpcy51c2FnZXMsXHJcbiAgICAgICAgICAgIGV4dDogdGhpcy5leHRyYWN0YWJsZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSkpO1xyXG4gICAgfVxyXG4gICAgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGlmICghanNvbi5jcnYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGdldCBuYW1lZCBjdXJ2ZSBmcm9tIEpXSy4gUHJvcGVydHkgJ2NydicgaXMgcmVxdWlyZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5hbGdvcml0aG0gPSBnZXRPaWRCeU5hbWVkQ3VydmUoanNvbi5jcnYpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihqc29uLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuQ3VydmVQcml2YXRlS2V5IH0pO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleSA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5KTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBFZFB1YmxpY0tleSBleHRlbmRzIEFzeW1tZXRyaWNLZXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInB1YmxpY1wiO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZSh0aGlzLmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgIHJldHVybiBrZXlJbmZvLnB1YmxpY0tleTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xyXG4gICAgICAgIGNvbnN0IGpzb24gPSB7XHJcbiAgICAgICAgICAgIGt0eTogXCJPS1BcIixcclxuICAgICAgICAgICAgY3J2OiB0aGlzLmFsZ29yaXRobS5uYW1lZEN1cnZlLFxyXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcclxuICAgICAgICAgICAgZXh0OiB0aGlzLmV4dHJhY3RhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oanNvbiwge1xyXG4gICAgICAgICAgICB4OiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybChrZXkpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgaWYgKCFqc29uLmNydikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgZ2V0IG5hbWVkIGN1cnZlIGZyb20gSldLLiBQcm9wZXJ0eSAnY3J2JyBpcyByZXF1aXJlZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWpzb24ueCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgZ2V0IHByb3BlcnR5IGZyb20gSldLLiBQcm9wZXJ0eSAneCcgaXMgcmVxdWlyZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gZ2V0T2lkQnlOYW1lZEN1cnZlKGpzb24uY3J2KTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleSA9IHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwoanNvbi54KTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBFZENyeXB0byB7XHJcbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IG5ldyBFZFByaXZhdGVLZXkoKTtcclxuICAgICAgICBwcml2YXRlS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBwcml2YXRlS2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAgcHJpdmF0ZUtleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wcml2YXRlS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XHJcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IEVkUHVibGljS2V5KCk7XHJcbiAgICAgICAgcHVibGljS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBwdWJsaWNLZXkuZXh0cmFjdGFibGUgPSB0cnVlO1xyXG4gICAgICAgIHB1YmxpY0tleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wdWJsaWNLZXlVc2FnZXMuaW5kZXhPZih1c2FnZSkgIT09IC0xKTtcclxuICAgICAgICBjb25zdCB0eXBlID0gYWxnb3JpdGhtLm5hbWVkQ3VydmUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gY3J5cHRvLmdlbmVyYXRlS2V5UGFpclN5bmModHlwZSwge1xyXG4gICAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzcGtpXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJwa2NzOFwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHByaXZhdGVLZXkuZGF0YSA9IGtleXMucHJpdmF0ZUtleTtcclxuICAgICAgICBwdWJsaWNLZXkuZGF0YSA9IGtleXMucHVibGljS2V5O1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleSxcclxuICAgICAgICAgICAgcHVibGljS2V5LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBzaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKCFrZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBrZXkucGVtLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gY3J5cHRvLnNpZ24obnVsbCwgQnVmZmVyLmZyb20oZGF0YSksIG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBjb3JlX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoc2lnbmF0dXJlKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyB2ZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIGlmICgha2V5LnBlbSkge1xyXG4gICAgICAgICAgICBrZXkucGVtID0gYC0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBrZXk6IGtleS5wZW0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBvayA9IGNyeXB0by52ZXJpZnkobnVsbCwgQnVmZmVyLmZyb20oZGF0YSksIG9wdGlvbnMsIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkpO1xyXG4gICAgICAgIHJldHVybiBvaztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZXJpdmVCaXRzKGFsZ29yaXRobSwgYmFzZUtleSwgbGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gY3J5cHRvLmNyZWF0ZVB1YmxpY0tleSh7XHJcbiAgICAgICAgICAgIGtleTogYWxnb3JpdGhtLnB1YmxpYy5kYXRhLFxyXG4gICAgICAgICAgICBmb3JtYXQ6IFwiZGVyXCIsXHJcbiAgICAgICAgICAgIHR5cGU6IFwic3BraVwiLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBjcnlwdG8uY3JlYXRlUHJpdmF0ZUtleSh7XHJcbiAgICAgICAgICAgIGtleTogYmFzZUtleS5kYXRhLFxyXG4gICAgICAgICAgICBmb3JtYXQ6IFwiZGVyXCIsXHJcbiAgICAgICAgICAgIHR5cGU6IFwicGtjczhcIixcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBiaXRzID0gY3J5cHRvLmRpZmZpZUhlbGxtYW4oe1xyXG4gICAgICAgICAgICBwdWJsaWNLZXksXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJpdHMpLmJ1ZmZlci5zbGljZSgwLCBsZW5ndGggPj4gMyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KTtcclxuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJzcGtpXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoa2V5LmRhdGEpLmJ1ZmZlcjtcclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNLZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5LmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1YmxpY0tleUluZm8ucHVibGljS2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snLCAncmF3JywgcGtjczgnIG9yICdzcGtpJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGp3ayA9IGtleURhdGE7XHJcbiAgICAgICAgICAgICAgICBpZiAoandrLmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oa2V5RGF0YSwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLkN1cnZlUHJpdmF0ZUtleSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghandrLngpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleURhdGE6IENhbm5vdCBnZXQgcmVxdWlyZWQgJ3gnIGZpbGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkocHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NFVybChqd2sueCksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoa2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGtleUluZm8ucHVibGljS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJwa2NzOFwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHJpdmF0ZUtleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuQ3VydmVQcml2YXRlS2V5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snLCAncmF3JywgJ3BrY3M4JyBvciAnc3BraSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgRWRQcml2YXRlS2V5KCk7XHJcbiAgICAgICAga2V5LmZyb21KU09OKHtcclxuICAgICAgICAgICAgY3J2OiBhbGdvcml0aG0ubmFtZWRDdXJ2ZSxcclxuICAgICAgICAgICAgZDogcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwoYXNuS2V5LmQpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgRWRQdWJsaWNLZXkoKTtcclxuICAgICAgICBrZXkuZnJvbUpTT04oe1xyXG4gICAgICAgICAgICBjcnY6IGFsZ29yaXRobS5uYW1lZEN1cnZlLFxyXG4gICAgICAgICAgICB4OiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybChhc25LZXkpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxufVxyXG5FZENyeXB0by5wdWJsaWNLZXlVc2FnZXMgPSBbXCJ2ZXJpZnlcIl07XHJcbkVkQ3J5cHRvLnByaXZhdGVLZXlVc2FnZXMgPSBbXCJzaWduXCIsIFwiZGVyaXZlS2V5XCIsIFwiZGVyaXZlQml0c1wiXTtcblxuY2xhc3MgRWREc2FQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5FZERzYVByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IEVkQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiBhbGdvcml0aG0ubmFtZWRDdXJ2ZS5yZXBsYWNlKC9eZWQvaSwgXCJFZFwiKSxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcclxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gRWRDcnlwdG8uc2lnbihhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEVkQ3J5cHRvLnZlcmlmeShhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShzaWduYXR1cmUpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBFZENyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEVkQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEVjZGhFc1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkVjZGhFc1Byb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IEVkQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiBhbGdvcml0aG0ubmFtZWRDdXJ2ZS50b1VwcGVyQ2FzZSgpLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVyaXZlQml0cyhhbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGJpdHMgPSBhd2FpdCBFZENyeXB0by5kZXJpdmVCaXRzKHsgLi4uYWxnb3JpdGhtLCBwdWJsaWM6IGdldENyeXB0b0tleShhbGdvcml0aG0ucHVibGljKSB9LCBnZXRDcnlwdG9LZXkoYmFzZUtleSksIGxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBFZENyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEVkQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFBia2RmQ3J5cHRvS2V5IGV4dGVuZHMgQ3J5cHRvS2V5IHtcclxufVxuXG5jbGFzcyBQYmtkZjJQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5QYmtkZjJQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzYWx0ID0gY29yZV9fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGFsZ29yaXRobS5zYWx0KTtcclxuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGFsZ29yaXRobS5oYXNoLm5hbWUucmVwbGFjZShcIi1cIiwgXCJcIik7XHJcbiAgICAgICAgICAgIGNyeXB0by5wYmtkZjIoZ2V0Q3J5cHRvS2V5KGJhc2VLZXkpLmRhdGEsIEJ1ZmZlci5mcm9tKHNhbHQpLCBhbGdvcml0aG0uaXRlcmF0aW9ucywgbGVuZ3RoID4+IDMsIGhhc2gsIChlcnIsIGRlcml2ZWRCaXRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBVaW50OEFycmF5KGRlcml2ZWRCaXRzKS5idWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJyYXdcIikge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBuZXcgUGJrZGZDcnlwdG9LZXkoKTtcclxuICAgICAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShrZXlEYXRhKTtcclxuICAgICAgICAgICAga2V5LmFsZ29yaXRobSA9IHsgbmFtZTogdGhpcy5uYW1lIH07XHJcbiAgICAgICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ3JhdydcIik7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBQYmtkZkNyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IFBCS0RGIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSG1hY0NyeXB0b0tleSBleHRlbmRzIENyeXB0b0tleSB7XHJcbiAgICBnZXQgYWxnKCkge1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLmFsZ29yaXRobS5oYXNoLm5hbWUudG9VcHBlckNhc2UoKTtcclxuICAgICAgICByZXR1cm4gYEhTJHtoYXNoLnJlcGxhY2UoXCJTSEEtXCIsIFwiXCIpfWA7XHJcbiAgICB9XHJcbiAgICBzZXQgYWxnKHZhbHVlKSB7XHJcbiAgICB9XHJcbn1cclxudHNsaWIuX19kZWNvcmF0ZShbXHJcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJrXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybENvbnZlcnRlciB9KVxyXG5dLCBIbWFjQ3J5cHRvS2V5LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG5cbmNsYXNzIEhtYWNQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5IbWFjUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSAoYWxnb3JpdGhtLmxlbmd0aCB8fCB0aGlzLmdldERlZmF1bHRMZW5ndGgoYWxnb3JpdGhtLmhhc2gubmFtZSkpID4+IDMgPDwgMztcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgSG1hY0NyeXB0b0tleSgpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSB7XHJcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcclxuICAgICAgICAgICAgbGVuZ3RoLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIGtleS5kYXRhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCA+PiAzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSBTaGFDcnlwdG8uZ2V0QWxnb3JpdGhtTmFtZShrZXkuYWxnb3JpdGhtLmhhc2gpO1xyXG4gICAgICAgIGNvbnN0IGhtYWMgPSBjcnlwdG8uY3JlYXRlSG1hYyhjcnlwdG9BbGcsIGdldENyeXB0b0tleShrZXkpLmRhdGEpXHJcbiAgICAgICAgICAgIC51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpLmRpZ2VzdCgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShobWFjKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gU2hhQ3J5cHRvLmdldEFsZ29yaXRobU5hbWUoa2V5LmFsZ29yaXRobS5oYXNoKTtcclxuICAgICAgICBjb25zdCBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoY3J5cHRvQWxnLCBnZXRDcnlwdG9LZXkoa2V5KS5kYXRhKVxyXG4gICAgICAgICAgICAudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKS5kaWdlc3QoKTtcclxuICAgICAgICByZXR1cm4gaG1hYy5jb21wYXJlKEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkpID09PSAwO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBsZXQga2V5O1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAga2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBIbWFjQ3J5cHRvS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IG5ldyBIbWFjQ3J5cHRvS2V5KCk7XHJcbiAgICAgICAgICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGtleURhdGEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snIG9yICdyYXcnXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0ge1xyXG4gICAgICAgICAgICBoYXNoOiB7IG5hbWU6IGFsZ29yaXRobS5oYXNoLm5hbWUgfSxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IGtleS5kYXRhLmxlbmd0aCA8PCAzLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGdldENyeXB0b0tleShrZXkpKTtcclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGdldENyeXB0b0tleShrZXkpLmRhdGEpLmJ1ZmZlcjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycgb3IgJ3JhdydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgSG1hY0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IEhNQUMgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBIa2RmQ3J5cHRvS2V5IGV4dGVuZHMgQ3J5cHRvS2V5IHtcclxufVxuXG5jbGFzcyBIa2RmUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuSGtkZlByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdC50b0xvd2VyQ2FzZSgpICE9PSBcInJhd1wiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJPcGVyYXRpb24gbm90IHN1cHBvcnRlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEhrZGZDcnlwdG9LZXkoKTtcclxuICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGtleURhdGEpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSB7IG5hbWU6IHRoaXMubmFtZSB9O1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZXJpdmVCaXRzKHBhcmFtcywgYmFzZUtleSwgbGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgaGFzaCA9IHBhcmFtcy5oYXNoLm5hbWUucmVwbGFjZShcIi1cIiwgXCJcIik7XHJcbiAgICAgICAgY29uc3QgaGFzaExlbmd0aCA9IGNyeXB0by5jcmVhdGVIYXNoKGhhc2gpLmRpZ2VzdCgpLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gbGVuZ3RoIC8gODtcclxuICAgICAgICBjb25zdCBpbmZvID0gY29yZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KHBhcmFtcy5pbmZvKTtcclxuICAgICAgICBjb25zdCBQUksgPSBjcnlwdG8uY3JlYXRlSG1hYyhoYXNoLCBjb3JlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkocGFyYW1zLnNhbHQpKVxyXG4gICAgICAgICAgICAudXBkYXRlKGNvcmUuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShnZXRDcnlwdG9LZXkoYmFzZUtleSkuZGF0YSkpXHJcbiAgICAgICAgICAgIC5kaWdlc3QoKTtcclxuICAgICAgICBjb25zdCBibG9ja3MgPSBbQnVmZmVyLmFsbG9jKDApXTtcclxuICAgICAgICBjb25zdCBibG9ja0NvdW50ID0gTWF0aC5jZWlsKGJ5dGVMZW5ndGggLyBoYXNoTGVuZ3RoKSArIDE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBibG9ja0NvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3J5cHRvLmNyZWF0ZUhtYWMoaGFzaCwgUFJLKVxyXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShCdWZmZXIuY29uY2F0KFtibG9ja3NbaSAtIDFdLCBpbmZvLCBCdWZmZXIuZnJvbShbaV0pXSkpXHJcbiAgICAgICAgICAgICAgICAuZGlnZXN0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChibG9ja3MpLnNsaWNlKDAsIGJ5dGVMZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgSGtkZkNyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IEhLREYgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGFrZUNyeXB0byB7XHJcbiAgICBzdGF0aWMgZGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0ubmFtZS50b0xvd2VyQ2FzZSgpLCB7IG91dHB1dExlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCB9KVxyXG4gICAgICAgICAgICAudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKS5kaWdlc3QoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGFzaCkuYnVmZmVyO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYWtlMTI4UHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuU2hha2UxMjhQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hha2VDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hha2UyNTZQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5TaGFrZTI1NlByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFrZUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTdWJ0bGVDcnlwdG8gZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuU3VidGxlQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgQWVzQ2JjUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBBZXNDdHJQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0djbVByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgQWVzQ21hY1Byb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgQWVzS3dQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0VjYlByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRGVzQ2JjUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBEZXNFZGUzQ2JjUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBSc2FTc2FQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFJzYVBzc1Byb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgUnNhT2FlcFByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgUnNhRXNQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEVjZHNhUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBFY2RoUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGExUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGEyNTZQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYTM4NFByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hhNTEyUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBQYmtkZjJQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEhtYWNQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEhrZGZQcm92aWRlcigpKTtcclxuICAgICAgICBjb25zdCBub2RlTWFqb3JWZXJzaW9uID0gKF9hID0gL152KFxcZCspLy5leGVjKHByb2Nlc3NfX25hbWVzcGFjZS52ZXJzaW9uKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzFdO1xyXG4gICAgICAgIGlmIChub2RlTWFqb3JWZXJzaW9uICYmIHBhcnNlSW50KG5vZGVNYWpvclZlcnNpb24sIDEwKSA+PSAxMikge1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYWtlMTI4UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hha2UyNTZQcm92aWRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGFzaGVzID0gY3J5cHRvX19uYW1lc3BhY2UuZ2V0SGFzaGVzKCk7XHJcbiAgICAgICAgaWYgKGhhc2hlcy5pbmNsdWRlcyhcInNoYTMtMjU2XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hhMzI1NlByb3ZpZGVyKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzaGVzLmluY2x1ZGVzKFwic2hhMy0zODRcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGEzMzg0UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNoZXMuaW5jbHVkZXMoXCJzaGEzLTUxMlwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYTM1MTJQcm92aWRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGVNYWpvclZlcnNpb24gJiYgcGFyc2VJbnQobm9kZU1ham9yVmVyc2lvbiwgMTApID49IDE0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRWREc2FQcm92aWRlcigpKTtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBFY2RoRXNQcm92aWRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgQ3J5cHRvIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuc3VidGxlID0gbmV3IFN1YnRsZUNyeXB0bygpO1xyXG4gICAgfVxyXG4gICAgZ2V0UmFuZG9tVmFsdWVzKGFycmF5KSB7XHJcbiAgICAgICAgaWYgKCFBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnZ2V0UmFuZG9tVmFsdWVzJyBvbiAnQ3J5cHRvJzogcGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ0FycmF5QnVmZmVyVmlldydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGFycmF5LmJ1ZmZlciwgYXJyYXkuYnl0ZU9mZnNldCwgYXJyYXkuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKGJ1ZmZlcik7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfVxyXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQ3J5cHRvS2V5Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmUuQ3J5cHRvS2V5OyB9XG59KTtcbmV4cG9ydHMuQ3J5cHRvID0gQ3J5cHRvO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/webcrypto/build/webcrypto.js\n");

/***/ })

};
;